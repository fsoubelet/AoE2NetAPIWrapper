{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"aoe2netwrapper A simple, efficient and typed wrapper to query the https://aoe2.net APIs with Python 3.6.1+ Link to documentation . Link to source code . License Copyright \u00a9 2021 Felix Soubelet. MIT License","title":"Home"},{"location":"#license","text":"Copyright \u00a9 2021 Felix Soubelet. MIT License","title":"License"},{"location":"docs/Features/","text":"Features Simple and Fully Typed The packages clients' methods mirror the aoe2.net endpoints, making the api objects easy and intuitive to use. They also come with sensible defaults everywhere possible. All of aoe2netwrapper is type hinted, providing autocompletion and return insights everywhere. No typing the wrong key names, coming back and forth between docs, or scrolling up and down to find if you need matchid or match_id . Validated Response Models The models used in aoe2netwrapper encapsulate and enhance the data returned by the aoe2.net APIs: No mess of confusing nested standard types: the methods all return tailored models encapsulating the returned data, recursively. No surprises: Data returned from the API is parsed and validated before being given back to you as custom models. Convenience: all models returned by the clients provide auto-completion on attributes, recursively. As for example below, the profile_id key inside a LeaderBoardSpot inside a LeaderBoardResponse that come from the https://aoe2.net/api/leaderboard endpoint. All the validation is handled by the well-established and robust pydantic . Models Integration All the other goodies from the returned pydantic models are available to you: exporting options, deep copies, ORM integration, etc. Built-In Results Conversion to Pandas DataFrames Installing the package with the dataframe extra gives access to the converters submodule, providing a high-level class to export results to pandas DataFrames. The class, Convert , provides static methods taking in the direct output given by the AoENetAPI 's query methods, and named after them. Logging & Testing 100% test coverage. A codebase making use of the amazing logging from loguru , which can be integrated and extended.","title":"Features"},{"location":"docs/Features/#features","text":"","title":"Features"},{"location":"docs/Features/#simple-and-fully-typed","text":"The packages clients' methods mirror the aoe2.net endpoints, making the api objects easy and intuitive to use. They also come with sensible defaults everywhere possible. All of aoe2netwrapper is type hinted, providing autocompletion and return insights everywhere. No typing the wrong key names, coming back and forth between docs, or scrolling up and down to find if you need matchid or match_id .","title":"Simple and Fully Typed"},{"location":"docs/Features/#validated-response-models","text":"The models used in aoe2netwrapper encapsulate and enhance the data returned by the aoe2.net APIs: No mess of confusing nested standard types: the methods all return tailored models encapsulating the returned data, recursively. No surprises: Data returned from the API is parsed and validated before being given back to you as custom models. Convenience: all models returned by the clients provide auto-completion on attributes, recursively. As for example below, the profile_id key inside a LeaderBoardSpot inside a LeaderBoardResponse that come from the https://aoe2.net/api/leaderboard endpoint. All the validation is handled by the well-established and robust pydantic . Models Integration All the other goodies from the returned pydantic models are available to you: exporting options, deep copies, ORM integration, etc.","title":"Validated Response Models"},{"location":"docs/Features/#built-in-results-conversion-to-pandas-dataframes","text":"Installing the package with the dataframe extra gives access to the converters submodule, providing a high-level class to export results to pandas DataFrames. The class, Convert , provides static methods taking in the direct output given by the AoENetAPI 's query methods, and named after them.","title":"Built-In Results Conversion to Pandas DataFrames"},{"location":"docs/Features/#logging-testing","text":"100% test coverage. A codebase making use of the amazing logging from loguru , which can be integrated and extended.","title":"Logging &amp; Testing"},{"location":"docs/Getting_Started/","text":"Getting Started Installation This code is compatible with Python 3.6.1+ . This package is installable from PyPI with pip in a virtual environment with: pip install aoe2netwrapper Installation in a virtual environment Don't know what a virtual environment is or how to set it up? Here is a good primer on virtual environments by RealPython. Extra Dependencies It is also possible to install with extra dependencies to access export functionnality from the package, with: pip install aoe2netwrapper [ dataframe ] How about a development environment? Sure thing. This repository uses Poetry as a packaging and build tool. To set yourself up, get a local copy through VCS and run: poetry install This repository follows the Google docstring format, uses Black as a code formatter with a default enforced line length of 110 characters, and Pylint as a linter. You can format the code with make format and lint it (which will format first) with make lint . Testing builds are ensured after each commit through Github Actions. You can run tests locally with the predefined make tests , or through poetry run pytest <options> for customized options. Quick Start The package provides a simple, fully-typed high-level object to interact with each API provided by aoe2.net . Each exposed endpoint from the APIs can be queried with a dedicated method named after it: Complete Data API from aoe2netwrapper import AoE2NetAPI # Specify timeout limit for ALL requests at instantiation client = AoE2NetAPI ( timeout = 10 ) # Get the first 100 ranked accounts in 1v1 Random Map top_accounts = client . leaderboard ( game = \"aoe2de\" , leaderboard_id = 3 , start = 1 , count = 100 ) # Get the list of currently open lobbies open_lobbies = client . lobbies ( game = \"aoe2de\" ) Nightbot API from aoe2netwrapper import AoE2NightbotAPI # Specify timeout limit for ALL requests at instantiation nightbot = AoE2NightbotAPI ( timeout = 10 ) # Get quick rank information on a specific player in 1v1 Random Map viper_details = nightbot . rank ( leaderboard_id = 3 , search = \"GL.TheViper\" ) print ( viper_details ) # '\ud83c\uddf3\ud83c\uddf4 GL.TheViper (2501) Rank #1, has played 762 games with a 69% winrate, -1 streak, and 2 drops' Converting Results to Pandas DataFrames from aoe2netwrapper import AoE2NetAPI from aoe2netwrapper.converters import Convert client = AoE2NetAPI ( timeout = 10 ) # Get the list of currently open lobbies, as a pandas dataframe open_lobbies = client . lobbies ( game = \"aoe2de\" ) lobbies_dframe = Convert . lobbies ( open_lobbies ) The full documentation for the API endpoints can be found at https://aoe2.net/#api and https://aoe2.net/#nightbot . For convenience, it is also included in the methods' docstrings, and can be accessed in the Reference section.","title":"Getting Started"},{"location":"docs/Getting_Started/#getting-started","text":"","title":"Getting Started"},{"location":"docs/Getting_Started/#installation","text":"This code is compatible with Python 3.6.1+ . This package is installable from PyPI with pip in a virtual environment with: pip install aoe2netwrapper Installation in a virtual environment Don't know what a virtual environment is or how to set it up? Here is a good primer on virtual environments by RealPython. Extra Dependencies It is also possible to install with extra dependencies to access export functionnality from the package, with: pip install aoe2netwrapper [ dataframe ] How about a development environment? Sure thing. This repository uses Poetry as a packaging and build tool. To set yourself up, get a local copy through VCS and run: poetry install This repository follows the Google docstring format, uses Black as a code formatter with a default enforced line length of 110 characters, and Pylint as a linter. You can format the code with make format and lint it (which will format first) with make lint . Testing builds are ensured after each commit through Github Actions. You can run tests locally with the predefined make tests , or through poetry run pytest <options> for customized options.","title":"Installation"},{"location":"docs/Getting_Started/#quick-start","text":"The package provides a simple, fully-typed high-level object to interact with each API provided by aoe2.net . Each exposed endpoint from the APIs can be queried with a dedicated method named after it: Complete Data API from aoe2netwrapper import AoE2NetAPI # Specify timeout limit for ALL requests at instantiation client = AoE2NetAPI ( timeout = 10 ) # Get the first 100 ranked accounts in 1v1 Random Map top_accounts = client . leaderboard ( game = \"aoe2de\" , leaderboard_id = 3 , start = 1 , count = 100 ) # Get the list of currently open lobbies open_lobbies = client . lobbies ( game = \"aoe2de\" ) Nightbot API from aoe2netwrapper import AoE2NightbotAPI # Specify timeout limit for ALL requests at instantiation nightbot = AoE2NightbotAPI ( timeout = 10 ) # Get quick rank information on a specific player in 1v1 Random Map viper_details = nightbot . rank ( leaderboard_id = 3 , search = \"GL.TheViper\" ) print ( viper_details ) # '\ud83c\uddf3\ud83c\uddf4 GL.TheViper (2501) Rank #1, has played 762 games with a 69% winrate, -1 streak, and 2 drops' Converting Results to Pandas DataFrames from aoe2netwrapper import AoE2NetAPI from aoe2netwrapper.converters import Convert client = AoE2NetAPI ( timeout = 10 ) # Get the list of currently open lobbies, as a pandas dataframe open_lobbies = client . lobbies ( game = \"aoe2de\" ) lobbies_dframe = Convert . lobbies ( open_lobbies ) The full documentation for the API endpoints can be found at https://aoe2.net/#api and https://aoe2.net/#nightbot . For convenience, it is also included in the methods' docstrings, and can be accessed in the Reference section.","title":"Quick Start"},{"location":"reference/aoe2netwrapper/","text":"Module aoe2netwrapper aoe2netwrapper library aoe2netwrapper is a utility library, written in Python 3, that provides high level clients to query the APIs provided by aoe2.net, and get data about the Age of Empires II video game. View Source \"\"\" aoe2netwrapper library ---------------------- aoe2netwrapper is a utility library, written in Python 3, that provides high level clients to query the APIs provided by aoe2.net, and get data about the Age of Empires II video game. :copyright: (c) 2021 by Felix Soubelet. :license: MIT, see LICENSE file for more details. \"\"\" from .api import AoE2NetAPI from .nightbot import AoE2NightbotAPI Sub-modules aoe2netwrapper.api aoe2netwrapper.converters aoe2netwrapper.exceptions aoe2netwrapper.models aoe2netwrapper.nightbot","title":"Index"},{"location":"reference/aoe2netwrapper/#module-aoe2netwrapper","text":"aoe2netwrapper library aoe2netwrapper is a utility library, written in Python 3, that provides high level clients to query the APIs provided by aoe2.net, and get data about the Age of Empires II video game. View Source \"\"\" aoe2netwrapper library ---------------------- aoe2netwrapper is a utility library, written in Python 3, that provides high level clients to query the APIs provided by aoe2.net, and get data about the Age of Empires II video game. :copyright: (c) 2021 by Felix Soubelet. :license: MIT, see LICENSE file for more details. \"\"\" from .api import AoE2NetAPI from .nightbot import AoE2NightbotAPI","title":"Module aoe2netwrapper"},{"location":"reference/aoe2netwrapper/#sub-modules","text":"aoe2netwrapper.api aoe2netwrapper.converters aoe2netwrapper.exceptions aoe2netwrapper.models aoe2netwrapper.nightbot","title":"Sub-modules"},{"location":"reference/aoe2netwrapper/api/","text":"Module aoe2netwrapper.api aoe2netwrapper.api This module implements a high-level client to query the API at https://aoe2.net/#api . View Source \"\"\" aoe2netwrapper.api ------------------ This module implements a high-level client to query the API at https://aoe2.net/#api. \"\"\" from typing import Any , Dict , List , Tuple , Union import requests from loguru import logger from pydantic import parse_obj_as from aoe2netwrapper.exceptions import Aoe2NetException from aoe2netwrapper.models import ( LastMatchResponse , LeaderBoardResponse , MatchLobby , NumOnlineResponse , RatingTimePoint , StringsResponse , ) class AoE2NetAPI : \"\"\" The 'AoE2NetAPI' class is a client that encompasses the https://aoe2.net/#api API endpoints. Each method in this class corresponds name for name to an endpoint, and will do the work in querying then parsing and validating the response before returning it. \"\"\" API_BASE_URL : str = \"https://aoe2.net/api\" STRINGS_ENDPOINT : str = API_BASE_URL + \"/strings\" LEADERBOARD_ENDPOINT : str = API_BASE_URL + \"/leaderboard\" LOBBIES_ENDPOINT : str = API_BASE_URL + \"/lobbies\" LAST_MATCH_ENDPOINT : str = API_BASE_URL + \"/player/lastmatch\" MATCH_HISTORY_ENDPOINT : str = API_BASE_URL + \"/player/matches\" RATING_HISTORY_ENDPOINT : str = API_BASE_URL + \"/player/ratinghistory\" MATCHES_ENDPOINT : str = API_BASE_URL + \"/matches\" MATCH_ENDPOINT : str = API_BASE_URL + \"/match\" NUMBER_ONLINE_ENDPOINT : str = API_BASE_URL + \"/stats/players\" def __init__ ( self , timeout : Union [ float , Tuple [ float , float ]] = 5 ): \"\"\"Creating a Session for connection pooling since we're always querying the same host.\"\"\" self . session = requests . Session () self . timeout = timeout def __repr__ ( self ) -> str : return f \"Client for <{self.API_BASE_URL}>\" def strings ( self , game : str = \"aoe2de\" ) -> StringsResponse : \"\"\" Requests a list of strings used by the API. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A StringsResponse validated object encapsulating the strings used by the API. \"\"\" logger . debug ( \"Preparing parameters for strings query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . STRINGS_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.STRINGS_ENDPOINT}'\" ) return StringsResponse ( ** processed_response ) def leaderboard ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , start : int = 1 , count : int = 10 , search : str = None , steam_id : int = None , profile_id : int = None , ) -> LeaderBoardResponse : \"\"\" Request the current leaderboards. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. start (int): Starting rank (ignored if search, steam_id, or profile_id are defined). Defaults to 1. count (int): Number of leaderboard entries to get (warning: must be 10000 or less). Defaults to 10. search (str): Optional. To perform the search for a specific player, from their name. steam_id (int): Optional. To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): Optional. To perform the search for a specific player, from their profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 10 000. Returns: A LeaderBoardResponse validated object with the different parameters used for the query, the total amount of hits, and the leaderboard as a list profile entries for each ranking. \"\"\" if count > 10 _000 : logger . error ( f \"'count' has to be 10000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) logger . debug ( \"Preparing parameters for leaderboard query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"start\" : start , \"count\" : count , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . LEADERBOARD_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LEADERBOARD_ENDPOINT}'\" ) return LeaderBoardResponse ( ** processed_response ) def lobbies ( self , game : str = \"aoe2de\" ) -> List [ MatchLobby ]: \"\"\" Request all open lobbies. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A list of MatchLobby valideted objects, each one encapsulating the data for a currently open lobby. \"\"\" logger . debug ( \"Preparing parameters for open lobbies query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . LOBBIES_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LOBBIES_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ], processed_response ) def last_match ( self , game : str = \"aoe2de\" , steam_id : int = None , profile_id : int = None ) -> LastMatchResponse : \"\"\" Request the last match the player started playing, this will be the current match if they are still in game. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A LastMatchResponse validated object with the information of the game, including the following attributes: 'profile_id', 'steam_id', 'name', 'clan', 'country' and 'last_match'. \"\"\" if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for last match query\" ) query_params = { \"game\" : game , \"steam_id\" : steam_id , \"profile_id\" : profile_id } processed_response = _get_request_response_json ( session = self . session , url = self . LAST_MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LAST_MATCH_ENDPOINT}'\" ) return LastMatchResponse ( ** processed_response ) def match_history ( self , game : str = \"aoe2de\" , start : int = 0 , count : int = 10 , steam_id : int = None , profile_id : int = None , ) -> List [ MatchLobby ]: \"\"\" Request the match history for a player. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). start (int): starting match (0 is the most recent match). Defaults to 0. count (int): number of matches to get (must be 1000 or less). Defaults to 10. steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 1000. Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A list of MatchLobby validated objects, each one encapsulating the data for one of the player's previous matches. \"\"\" if count > 1 _000 : logger . error ( f \"'count' has to be 1000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for match history query\" ) query_params = { \"game\" : game , \"start\" : start , \"count\" : count , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCH_HISTORY_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCH_HISTORY_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ], processed_response ) def rating_history ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , start : int = 0 , count : int = 20 , steam_id : int = None , profile_id : int = None , ) -> List [ RatingTimePoint ]: \"\"\" Requests the rating history for a player. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. start (int): starting match (0 is the most recent match). Defaults to 0. count (int): number of matches to get the rating for (must be 1000 or less). Defaults to 100. steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 10 000. Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A list of RatingTimePoint validated objects, each one encapsulating data at a certain point in time corresponding to a match played by the player, including the rating, timestamp of the match, streaks etc. \"\"\" if count > 10 _000 : logger . error ( f \"'count' has to be 10 000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for rating history query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"start\" : start , \"count\" : count , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . RATING_HISTORY_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.RATING_HISTORY_ENDPOINT}'\" ) return parse_obj_as ( List [ RatingTimePoint ], processed_response ) def matches ( self , game : str = \"aoe2de\" , count : int = 10 , since : int = None ) -> List [ MatchLobby ]: \"\"\" Request matches after a specific time: the match history in an optionally given time window. If 'since' is not set, only the X amount of current past matches (specified by 'count') will be returned. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). count (int): number of matches to get (must be 1000 or less). Defaults to 10. since (int): only show matches starting after 'since' timestamp (epoch). Raises: Aoe2NetException: if the 'count' parameter exceeds 1000. Returns: A list of MatchLobby validated objects, each one encapsulating the data for one of the played matches during the time window queried for. \"\"\" if count > 1000 : logger . error ( f \"'count' has to be 1000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) logger . debug ( \"Preparing parameters for matches query\" ) query_params = { \"game\" : game , \"count\" : count , \"since\" : since , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCHES_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCHES_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ], processed_response ) def match ( self , game : str = \"aoe2de\" , uuid : str = None , match_id : int = None ) -> MatchLobby : \"\"\" Request details about a match. Either 'uuid' or 'match_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). uuid (str): match UUID (ex: '66ec2575-5ee4-d241-a1fc-d7ffeffb48b6'). match_id (int): match ID. Raises: Aoe2NetException: if the not one of 'uuid' or 'match_id' are provided. Returns: A MatchLobby validated object with the information of the specific match, including. \"\"\" if not uuid and not match_id : logger . error ( \"Missing one of 'uuid', 'match_id'.\" ) raise Aoe2NetException ( \"Either 'uuid' or 'match_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for single match query\" ) query_params = { \"game\" : game , \"uuid\" : uuid , \"match_id\" : match_id , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCH_ENDPOINT}'\" ) return MatchLobby ( ** processed_response ) def num_online ( self , game : str = \"aoe2de\" ) -> NumOnlineResponse : \"\"\" Number of players in game and an estimate of the number current playing multiplayer. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A NumOnlineResponse validated object with the app id and a list of PlayerCountTimePoint validated objects encapsulating estimated metrics at different timestamps ('steam', 'multiplayer', 'looking', 'in_game', 'multiplayer_1h' & 'multiplayer_24h'). \"\"\" logger . debug ( \"Preparing parameters for number of online players query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . NUMBER_ONLINE_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.NUMBER_ONLINE_ENDPOINT}'\" ) return NumOnlineResponse ( ** processed_response ) # ----- Helpers ----- # def _get_request_response_json ( session : requests . Session , url : str , params : Dict [ str , Any ] = None , timeout : Union [ float , Tuple [ float , float ]] = None , ) -> dict : \"\"\" Helper function to handle a GET request to an endpoint and return the response JSON content as a dictionary. Args: session (requests.Session): Session object to use, for connection pooling and performance. url (str): API endpoint to send the request to. params (dict): A dictionary of parameters for the GET request. Raises: Aoe2NetException: if the status code returned is not 200. Returns: The request's JSON response as a dictionary. \"\"\" default_headers = { \"content-type\" : \"application/json;charset=UTF-8\" } logger . debug ( f \"Sending GET request at '{url}'\" ) logger . trace ( f \"Parameters are: {str(params)}\" ) response = session . get ( url , params = params , headers = default_headers , timeout = timeout ) if response . status_code != 200 : logger . error ( f \"GET request at '{response.url}' returned a {response.status_code} status code\" ) raise Aoe2NetException ( f \"Expected status code 200 - got {response.status_code} instead.\" ) return response . json () Classes AoE2NetAPI class AoE2NetAPI ( timeout : Union [ float , Tuple [ float , float ]] = 5 ) View Source class AoE2NetAPI : \"\"\" The 'AoE2NetAPI' class is a client that encompasses the https://aoe2.net/#api API endpoints. Each method in this class corresponds name for name to an endpoint, and will do the work in querying then parsing and validating the response before returning it. \"\"\" API_BASE_URL : str = \"https://aoe2.net/api\" STRINGS_ENDPOINT : str = API_BASE_URL + \"/strings\" LEADERBOARD_ENDPOINT : str = API_BASE_URL + \"/leaderboard\" LOBBIES_ENDPOINT : str = API_BASE_URL + \"/lobbies\" LAST_MATCH_ENDPOINT : str = API_BASE_URL + \"/player/lastmatch\" MATCH_HISTORY_ENDPOINT : str = API_BASE_URL + \"/player/matches\" RATING_HISTORY_ENDPOINT : str = API_BASE_URL + \"/player/ratinghistory\" MATCHES_ENDPOINT : str = API_BASE_URL + \"/matches\" MATCH_ENDPOINT : str = API_BASE_URL + \"/match\" NUMBER_ONLINE_ENDPOINT : str = API_BASE_URL + \"/stats/players\" def __init__ ( self , timeout : Union [ float, Tuple[float, float ] ] = 5 ) : \"\"\"Creating a Session for connection pooling since we're always querying the same host.\"\"\" self . session = requests . Session () self . timeout = timeout def __repr__ ( self ) -> str : return f \"Client for <{self.API_BASE_URL}>\" def strings ( self , game : str = \"aoe2de\" ) -> StringsResponse : \"\"\" Requests a list of strings used by the API. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A StringsResponse validated object encapsulating the strings used by the API. \"\"\" logger . debug ( \"Preparing parameters for strings query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . STRINGS_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.STRINGS_ENDPOINT}'\" ) return StringsResponse ( ** processed_response ) def leaderboard ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , start : int = 1 , count : int = 10 , search : str = None , steam_id : int = None , profile_id : int = None , ) -> LeaderBoardResponse : \"\"\" Request the current leaderboards. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. start (int): Starting rank (ignored if search, steam_id, or profile_id are defined). Defaults to 1. count (int): Number of leaderboard entries to get (warning: must be 10000 or less). Defaults to 10. search (str): Optional. To perform the search for a specific player, from their name. steam_id (int): Optional. To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): Optional. To perform the search for a specific player, from their profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 10 000. Returns: A LeaderBoardResponse validated object with the different parameters used for the query, the total amount of hits, and the leaderboard as a list profile entries for each ranking. \"\"\" if count > 10 _000 : logger . error ( f \"'count' has to be 10000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) logger . debug ( \"Preparing parameters for leaderboard query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"start\" : start , \"count\" : count , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . LEADERBOARD_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LEADERBOARD_ENDPOINT}'\" ) return LeaderBoardResponse ( ** processed_response ) def lobbies ( self , game : str = \"aoe2de\" ) -> List [ MatchLobby ] : \"\"\" Request all open lobbies. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A list of MatchLobby valideted objects, each one encapsulating the data for a currently open lobby. \"\"\" logger . debug ( \"Preparing parameters for open lobbies query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . LOBBIES_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LOBBIES_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ] , processed_response ) def last_match ( self , game : str = \"aoe2de\" , steam_id : int = None , profile_id : int = None ) -> LastMatchResponse : \"\"\" Request the last match the player started playing, this will be the current match if they are still in game. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A LastMatchResponse validated object with the information of the game, including the following attributes: 'profile_id', 'steam_id', 'name', 'clan', 'country' and 'last_match'. \"\"\" if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for last match query\" ) query_params = { \"game\" : game , \"steam_id\" : steam_id , \"profile_id\" : profile_id } processed_response = _get_request_response_json ( session = self . session , url = self . LAST_MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LAST_MATCH_ENDPOINT}'\" ) return LastMatchResponse ( ** processed_response ) def match_history ( self , game : str = \"aoe2de\" , start : int = 0 , count : int = 10 , steam_id : int = None , profile_id : int = None , ) -> List [ MatchLobby ] : \"\"\" Request the match history for a player. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). start (int): starting match (0 is the most recent match). Defaults to 0. count (int): number of matches to get (must be 1000 or less). Defaults to 10. steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 1000. Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A list of MatchLobby validated objects, each one encapsulating the data for one of the player's previous matches. \"\"\" if count > 1 _000 : logger . error ( f \"'count' has to be 1000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for match history query\" ) query_params = { \"game\" : game , \"start\" : start , \"count\" : count , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCH_HISTORY_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCH_HISTORY_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ] , processed_response ) def rating_history ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , start : int = 0 , count : int = 20 , steam_id : int = None , profile_id : int = None , ) -> List [ RatingTimePoint ] : \"\"\" Requests the rating history for a player. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. start (int): starting match (0 is the most recent match). Defaults to 0. count (int): number of matches to get the rating for (must be 1000 or less). Defaults to 100. steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 10 000. Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A list of RatingTimePoint validated objects, each one encapsulating data at a certain point in time corresponding to a match played by the player, including the rating, timestamp of the match, streaks etc. \"\"\" if count > 10 _000 : logger . error ( f \"'count' has to be 10 000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for rating history query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"start\" : start , \"count\" : count , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . RATING_HISTORY_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.RATING_HISTORY_ENDPOINT}'\" ) return parse_obj_as ( List [ RatingTimePoint ] , processed_response ) def matches ( self , game : str = \"aoe2de\" , count : int = 10 , since : int = None ) -> List [ MatchLobby ] : \"\"\" Request matches after a specific time: the match history in an optionally given time window. If 'since' is not set, only the X amount of current past matches (specified by 'count') will be returned. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). count (int): number of matches to get (must be 1000 or less). Defaults to 10. since (int): only show matches starting after 'since' timestamp (epoch). Raises: Aoe2NetException: if the 'count' parameter exceeds 1000. Returns: A list of MatchLobby validated objects, each one encapsulating the data for one of the played matches during the time window queried for. \"\"\" if count > 1000 : logger . error ( f \"'count' has to be 1000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) logger . debug ( \"Preparing parameters for matches query\" ) query_params = { \"game\" : game , \"count\" : count , \"since\" : since , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCHES_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCHES_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ] , processed_response ) def match ( self , game : str = \"aoe2de\" , uuid : str = None , match_id : int = None ) -> MatchLobby : \"\"\" Request details about a match. Either 'uuid' or 'match_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). uuid (str): match UUID (ex: '66ec2575-5ee4-d241-a1fc-d7ffeffb48b6'). match_id (int): match ID. Raises: Aoe2NetException: if the not one of 'uuid' or 'match_id' are provided. Returns: A MatchLobby validated object with the information of the specific match, including. \"\"\" if not uuid and not match_id : logger . error ( \"Missing one of 'uuid', 'match_id'.\" ) raise Aoe2NetException ( \"Either 'uuid' or 'match_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for single match query\" ) query_params = { \"game\" : game , \"uuid\" : uuid , \"match_id\" : match_id , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCH_ENDPOINT}'\" ) return MatchLobby ( ** processed_response ) def num_online ( self , game : str = \"aoe2de\" ) -> NumOnlineResponse : \"\"\" Number of players in game and an estimate of the number current playing multiplayer. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A NumOnlineResponse validated object with the app id and a list of PlayerCountTimePoint validated objects encapsulating estimated metrics at different timestamps ('steam', 'multiplayer', 'looking', 'in_game', 'multiplayer_1h' & 'multiplayer_24h'). \"\"\" logger . debug ( \"Preparing parameters for number of online players query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . NUMBER_ONLINE_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.NUMBER_ONLINE_ENDPOINT}'\" ) return NumOnlineResponse ( ** processed_response ) Class variables API_BASE_URL LAST_MATCH_ENDPOINT LEADERBOARD_ENDPOINT LOBBIES_ENDPOINT MATCHES_ENDPOINT MATCH_ENDPOINT MATCH_HISTORY_ENDPOINT NUMBER_ONLINE_ENDPOINT RATING_HISTORY_ENDPOINT STRINGS_ENDPOINT Methods last_match def last_match ( self , game : str = 'aoe2de' , steam_id : int = None , profile_id : int = None ) -> aoe2netwrapper . models . last_match . LastMatchResponse Request the last match the player started playing, this will be the current match if they are still in game. Either 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' steam_id int The player's steamID64 (ex: 76561199003184910). None profile_id int The player's profile ID (ex: 459658). None Returns: Type Description None A LastMatchResponse validated object with the information of the game, including the following attributes: 'profile_id', 'steam_id', 'name', 'clan', 'country' and 'last_match'. Raises: Type Description Aoe2NetException if the not one of 'steam_id' or 'profile_id' are provided. View Source def last_match ( self , game : str = \"aoe2de\" , steam_id : int = None , profile_id : int = None ) -> LastMatchResponse : \"\" \" Request the last match the player started playing , this will be the current match if they are still in game . Either 'steam_id' or 'profile_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). steam_id ( int ): The player ' s steamID64 ( ex : 76561199003184910 ). profile_id ( int ): The player ' s profile ID ( ex : 459658 ). Raises : Aoe2NetException : if the not one of 'steam_id' or 'profile_id' are provided . Returns : A LastMatchResponse validated object with the information of the game , including the following attributes : 'profile_id' , 'steam_id' , 'name' , 'clan' , 'country' and 'last_match' . \"\" \" if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for last match query\" ) query_params = { \"game\" : game , \"steam_id\" : steam_id , \"profile_id\" : profile_id } processed_response = _get_request_response_json ( session = self . session , url = self . LAST_MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LAST_MATCH_ENDPOINT}'\" ) return LastMatchResponse ( ** processed_response ) leaderboard def leaderboard ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , start : int = 1 , count : int = 10 , search : str = None , steam_id : int = None , profile_id : int = None ) -> aoe2netwrapper . models . leaderboard . LeaderBoardResponse Request the current leaderboards. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None start int Starting rank (ignored if search, steam_id, or profile_id are defined). Defaults to 1. None count int Number of leaderboard entries to get (warning: must be 10000 or less). Defaults to 10. None search str Optional. To perform the search for a specific player, from their name. None steam_id int Optional. To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). None profile_id int Optional. To perform the search for a specific player, from their profile ID (ex: 459658). None Returns: Type Description None A LeaderBoardResponse validated object with the different parameters used for the query, the total amount of hits, and the leaderboard as a list profile entries for each ranking. Raises: Type Description Aoe2NetException if the 'count' parameter exceeds 10 000. View Source def leaderboard ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , start : int = 1 , count : int = 10 , search : str = None , steam_id : int = None , profile_id : int = None , ) -> LeaderBoardResponse : \"\" \" Request the current leaderboards . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). leaderboard_id ( int ): Leaderboard to extract the data for ( Unranked = 0 , 1 v1 Deathmatch = 1 , Team Deathmatch = 2 , 1 v1 Random Map = 3 , Team Random Map = 4 ). Defaults to 3 . start ( int ): Starting rank ( ignored if search , steam_id , or profile_id are defined ). Defaults to 1 . count ( int ): Number of leaderboard entries to get ( warning : must be 10000 or less ). Defaults to 10 . search ( str ): Optional . To perform the search for a specific player , from their name . steam_id ( int ): Optional . To perform the search for a specific player , from their steamID64 ( ex : 76561199003184910 ). profile_id ( int ): Optional . To perform the search for a specific player , from their profile ID ( ex : 459658 ). Raises : Aoe2NetException : if the 'count' parameter exceeds 10 000 . Returns : A LeaderBoardResponse validated object with the different parameters used for the query , the total amount of hits , and the leaderboard as a list profile entries for each ranking . \"\" \" if count > 10 _000 : logger . error ( f \"'count' has to be 10000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) logger . debug ( \"Preparing parameters for leaderboard query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"start\" : start , \"count\" : count , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . LEADERBOARD_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LEADERBOARD_ENDPOINT}'\" ) return LeaderBoardResponse ( ** processed_response ) lobbies def lobbies ( self , game : str = 'aoe2de' ) -> List [ aoe2netwrapper . models . lobbies . MatchLobby ] Request all open lobbies. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' Returns: Type Description None A list of MatchLobby valideted objects, each one encapsulating the data for a currently open lobby. View Source def lobbies ( self , game : str = \"aoe2de\" ) -> List [ MatchLobby ] : \"\"\" Request all open lobbies. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A list of MatchLobby valideted objects, each one encapsulating the data for a currently open lobby. \"\"\" logger . debug ( \"Preparing parameters for open lobbies query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . LOBBIES_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LOBBIES_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ] , processed_response ) match def match ( self , game : str = 'aoe2de' , uuid : str = None , match_id : int = None ) -> aoe2netwrapper . models . lobbies . MatchLobby Request details about a match. Either 'uuid' or 'match_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' uuid str match UUID (ex: '66ec2575-5ee4-d241-a1fc-d7ffeffb48b6'). None match_id int match ID. None Returns: Type Description None A MatchLobby validated object with the information of the specific match, including. Raises: Type Description Aoe2NetException if the not one of 'uuid' or 'match_id' are provided. View Source def match ( self , game : str = \"aoe2de\" , uuid : str = None , match_id : int = None ) -> MatchLobby : \"\" \" Request details about a match . Either 'uuid' or 'match_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). uuid ( str ): match UUID ( ex : '66ec2575-5ee4-d241-a1fc-d7ffeffb48b6' ). match_id ( int ): match ID . Raises : Aoe2NetException : if the not one of 'uuid' or 'match_id' are provided . Returns : A MatchLobby validated object with the information of the specific match , including . \"\" \" if not uuid and not match_id : logger . error ( \"Missing one of 'uuid', 'match_id'.\" ) raise Aoe2NetException ( \"Either 'uuid' or 'match_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for single match query\" ) query_params = { \"game\" : game , \"uuid\" : uuid , \"match_id\" : match_id , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCH_ENDPOINT}'\" ) return MatchLobby ( ** processed_response ) match_history def match_history ( self , game : str = 'aoe2de' , start : int = 0 , count : int = 10 , steam_id : int = None , profile_id : int = None ) -> List [ aoe2netwrapper . models . lobbies . MatchLobby ] Request the match history for a player. Either 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' start int starting match (0 is the most recent match). Defaults to 0. 0 count int number of matches to get (must be 1000 or less). Defaults to 10. 10 steam_id int The player's steamID64 (ex: 76561199003184910). None profile_id int The player's profile ID (ex: 459658). None Returns: Type Description None A list of MatchLobby validated objects, each one encapsulating the data for one of the player's previous matches. Raises: Type Description Aoe2NetException if the 'count' parameter exceeds 1000. Aoe2NetException if the not one of 'steam_id' or 'profile_id' are provided. View Source def match_history ( self , game : str = \"aoe2de\" , start : int = 0 , count : int = 10 , steam_id : int = None , profile_id : int = None , ) -> List [ MatchLobby ] : \"\"\" Request the match history for a player. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). start (int): starting match (0 is the most recent match). Defaults to 0. count (int): number of matches to get (must be 1000 or less). Defaults to 10. steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 1000. Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A list of MatchLobby validated objects, each one encapsulating the data for one of the player's previous matches. \"\"\" if count > 1 _000 : logger . error ( f \"'count' has to be 1000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for match history query\" ) query_params = { \"game\" : game , \"start\" : start , \"count\" : count , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCH_HISTORY_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCH_HISTORY_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ] , processed_response ) matches def matches ( self , game : str = 'aoe2de' , count : int = 10 , since : int = None ) -> List [ aoe2netwrapper . models . lobbies . MatchLobby ] Request matches after a specific time: the match history in an optionally given time window. If 'since' is not set, only the X amount of current past matches (specified by 'count') will be returned. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' count int number of matches to get (must be 1000 or less). Defaults to 10. 10 since int only show matches starting after 'since' timestamp (epoch). None Returns: Type Description None A list of MatchLobby validated objects, each one encapsulating the data for one of the played matches during the time window queried for. Raises: Type Description Aoe2NetException if the 'count' parameter exceeds 1000. View Source def matches ( self , game : str = \"aoe2de\" , count : int = 10 , since : int = None ) -> List [ MatchLobby ] : \"\"\" Request matches after a specific time: the match history in an optionally given time window. If 'since' is not set, only the X amount of current past matches (specified by 'count') will be returned. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). count (int): number of matches to get (must be 1000 or less). Defaults to 10. since (int): only show matches starting after 'since' timestamp (epoch). Raises: Aoe2NetException: if the 'count' parameter exceeds 1000. Returns: A list of MatchLobby validated objects, each one encapsulating the data for one of the played matches during the time window queried for. \"\"\" if count > 1000 : logger . error ( f \"'count' has to be 1000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) logger . debug ( \"Preparing parameters for matches query\" ) query_params = { \"game\" : game , \"count\" : count , \"since\" : since , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCHES_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCHES_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ] , processed_response ) num_online def num_online ( self , game : str = 'aoe2de' ) -> aoe2netwrapper . models . num_online . NumOnlineResponse Number of players in game and an estimate of the number current playing multiplayer. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' Returns: Type Description None A NumOnlineResponse validated object with the app id and a list of PlayerCountTimePoint validated objects encapsulating estimated metrics at different timestamps ('steam', 'multiplayer', 'looking', 'in_game', 'multiplayer_1h' & 'multiplayer_24h'). View Source def num_online ( self , game : str = \"aoe2de\" ) -> NumOnlineResponse : \"\" \" Number of players in game and an estimate of the number current playing multiplayer . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). Returns : A NumOnlineResponse validated object with the app id and a list of PlayerCountTimePoint validated objects encapsulating estimated metrics at different timestamps ( 'steam' , 'multiplayer' , 'looking' , 'in_game' , 'multiplayer_1h' & 'multiplayer_24h' ). \"\" \" logger . debug ( \"Preparing parameters for number of online players query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . NUMBER_ONLINE_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.NUMBER_ONLINE_ENDPOINT}'\" ) return NumOnlineResponse ( ** processed_response ) rating_history def rating_history ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , start : int = 0 , count : int = 20 , steam_id : int = None , profile_id : int = None ) -> List [ aoe2netwrapper . models . rating_history . RatingTimePoint ] Requests the rating history for a player. Either 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None start int starting match (0 is the most recent match). Defaults to 0. 0 count int number of matches to get the rating for (must be 1000 or less). Defaults to 100. None steam_id int The player's steamID64 (ex: 76561199003184910). None profile_id int The player's profile ID (ex: 459658). None Returns: Type Description None A list of RatingTimePoint validated objects, each one encapsulating data at a certain point in time corresponding to a match played by the player, including the rating, timestamp of the match, streaks etc. Raises: Type Description Aoe2NetException if the 'count' parameter exceeds 10 000. Aoe2NetException if the not one of 'steam_id' or 'profile_id' are provided. View Source def rating_history ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , start : int = 0 , count : int = 20 , steam_id : int = None , profile_id : int = None , ) -> List [ RatingTimePoint ] : \"\"\" Requests the rating history for a player. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. start (int): starting match (0 is the most recent match). Defaults to 0. count (int): number of matches to get the rating for (must be 1000 or less). Defaults to 100. steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 10 000. Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A list of RatingTimePoint validated objects, each one encapsulating data at a certain point in time corresponding to a match played by the player, including the rating, timestamp of the match, streaks etc. \"\"\" if count > 10 _000 : logger . error ( f \"'count' has to be 10 000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for rating history query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"start\" : start , \"count\" : count , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . RATING_HISTORY_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.RATING_HISTORY_ENDPOINT}'\" ) return parse_obj_as ( List [ RatingTimePoint ] , processed_response ) strings def strings ( self , game : str = 'aoe2de' ) -> aoe2netwrapper . models . strings . StringsResponse Requests a list of strings used by the API. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' Returns: Type Description None A StringsResponse validated object encapsulating the strings used by the API. View Source def strings ( self , game : str = \"aoe2de\" ) -> StringsResponse : \"\" \" Requests a list of strings used by the API . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). Returns : A StringsResponse validated object encapsulating the strings used by the API . \"\" \" logger . debug ( \"Preparing parameters for strings query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . STRINGS_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.STRINGS_ENDPOINT}'\" ) return StringsResponse ( ** processed_response )","title":"API"},{"location":"reference/aoe2netwrapper/api/#module-aoe2netwrapperapi","text":"aoe2netwrapper.api This module implements a high-level client to query the API at https://aoe2.net/#api . View Source \"\"\" aoe2netwrapper.api ------------------ This module implements a high-level client to query the API at https://aoe2.net/#api. \"\"\" from typing import Any , Dict , List , Tuple , Union import requests from loguru import logger from pydantic import parse_obj_as from aoe2netwrapper.exceptions import Aoe2NetException from aoe2netwrapper.models import ( LastMatchResponse , LeaderBoardResponse , MatchLobby , NumOnlineResponse , RatingTimePoint , StringsResponse , ) class AoE2NetAPI : \"\"\" The 'AoE2NetAPI' class is a client that encompasses the https://aoe2.net/#api API endpoints. Each method in this class corresponds name for name to an endpoint, and will do the work in querying then parsing and validating the response before returning it. \"\"\" API_BASE_URL : str = \"https://aoe2.net/api\" STRINGS_ENDPOINT : str = API_BASE_URL + \"/strings\" LEADERBOARD_ENDPOINT : str = API_BASE_URL + \"/leaderboard\" LOBBIES_ENDPOINT : str = API_BASE_URL + \"/lobbies\" LAST_MATCH_ENDPOINT : str = API_BASE_URL + \"/player/lastmatch\" MATCH_HISTORY_ENDPOINT : str = API_BASE_URL + \"/player/matches\" RATING_HISTORY_ENDPOINT : str = API_BASE_URL + \"/player/ratinghistory\" MATCHES_ENDPOINT : str = API_BASE_URL + \"/matches\" MATCH_ENDPOINT : str = API_BASE_URL + \"/match\" NUMBER_ONLINE_ENDPOINT : str = API_BASE_URL + \"/stats/players\" def __init__ ( self , timeout : Union [ float , Tuple [ float , float ]] = 5 ): \"\"\"Creating a Session for connection pooling since we're always querying the same host.\"\"\" self . session = requests . Session () self . timeout = timeout def __repr__ ( self ) -> str : return f \"Client for <{self.API_BASE_URL}>\" def strings ( self , game : str = \"aoe2de\" ) -> StringsResponse : \"\"\" Requests a list of strings used by the API. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A StringsResponse validated object encapsulating the strings used by the API. \"\"\" logger . debug ( \"Preparing parameters for strings query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . STRINGS_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.STRINGS_ENDPOINT}'\" ) return StringsResponse ( ** processed_response ) def leaderboard ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , start : int = 1 , count : int = 10 , search : str = None , steam_id : int = None , profile_id : int = None , ) -> LeaderBoardResponse : \"\"\" Request the current leaderboards. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. start (int): Starting rank (ignored if search, steam_id, or profile_id are defined). Defaults to 1. count (int): Number of leaderboard entries to get (warning: must be 10000 or less). Defaults to 10. search (str): Optional. To perform the search for a specific player, from their name. steam_id (int): Optional. To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): Optional. To perform the search for a specific player, from their profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 10 000. Returns: A LeaderBoardResponse validated object with the different parameters used for the query, the total amount of hits, and the leaderboard as a list profile entries for each ranking. \"\"\" if count > 10 _000 : logger . error ( f \"'count' has to be 10000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) logger . debug ( \"Preparing parameters for leaderboard query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"start\" : start , \"count\" : count , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . LEADERBOARD_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LEADERBOARD_ENDPOINT}'\" ) return LeaderBoardResponse ( ** processed_response ) def lobbies ( self , game : str = \"aoe2de\" ) -> List [ MatchLobby ]: \"\"\" Request all open lobbies. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A list of MatchLobby valideted objects, each one encapsulating the data for a currently open lobby. \"\"\" logger . debug ( \"Preparing parameters for open lobbies query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . LOBBIES_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LOBBIES_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ], processed_response ) def last_match ( self , game : str = \"aoe2de\" , steam_id : int = None , profile_id : int = None ) -> LastMatchResponse : \"\"\" Request the last match the player started playing, this will be the current match if they are still in game. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A LastMatchResponse validated object with the information of the game, including the following attributes: 'profile_id', 'steam_id', 'name', 'clan', 'country' and 'last_match'. \"\"\" if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for last match query\" ) query_params = { \"game\" : game , \"steam_id\" : steam_id , \"profile_id\" : profile_id } processed_response = _get_request_response_json ( session = self . session , url = self . LAST_MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LAST_MATCH_ENDPOINT}'\" ) return LastMatchResponse ( ** processed_response ) def match_history ( self , game : str = \"aoe2de\" , start : int = 0 , count : int = 10 , steam_id : int = None , profile_id : int = None , ) -> List [ MatchLobby ]: \"\"\" Request the match history for a player. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). start (int): starting match (0 is the most recent match). Defaults to 0. count (int): number of matches to get (must be 1000 or less). Defaults to 10. steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 1000. Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A list of MatchLobby validated objects, each one encapsulating the data for one of the player's previous matches. \"\"\" if count > 1 _000 : logger . error ( f \"'count' has to be 1000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for match history query\" ) query_params = { \"game\" : game , \"start\" : start , \"count\" : count , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCH_HISTORY_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCH_HISTORY_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ], processed_response ) def rating_history ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , start : int = 0 , count : int = 20 , steam_id : int = None , profile_id : int = None , ) -> List [ RatingTimePoint ]: \"\"\" Requests the rating history for a player. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. start (int): starting match (0 is the most recent match). Defaults to 0. count (int): number of matches to get the rating for (must be 1000 or less). Defaults to 100. steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 10 000. Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A list of RatingTimePoint validated objects, each one encapsulating data at a certain point in time corresponding to a match played by the player, including the rating, timestamp of the match, streaks etc. \"\"\" if count > 10 _000 : logger . error ( f \"'count' has to be 10 000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for rating history query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"start\" : start , \"count\" : count , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . RATING_HISTORY_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.RATING_HISTORY_ENDPOINT}'\" ) return parse_obj_as ( List [ RatingTimePoint ], processed_response ) def matches ( self , game : str = \"aoe2de\" , count : int = 10 , since : int = None ) -> List [ MatchLobby ]: \"\"\" Request matches after a specific time: the match history in an optionally given time window. If 'since' is not set, only the X amount of current past matches (specified by 'count') will be returned. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). count (int): number of matches to get (must be 1000 or less). Defaults to 10. since (int): only show matches starting after 'since' timestamp (epoch). Raises: Aoe2NetException: if the 'count' parameter exceeds 1000. Returns: A list of MatchLobby validated objects, each one encapsulating the data for one of the played matches during the time window queried for. \"\"\" if count > 1000 : logger . error ( f \"'count' has to be 1000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) logger . debug ( \"Preparing parameters for matches query\" ) query_params = { \"game\" : game , \"count\" : count , \"since\" : since , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCHES_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCHES_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ], processed_response ) def match ( self , game : str = \"aoe2de\" , uuid : str = None , match_id : int = None ) -> MatchLobby : \"\"\" Request details about a match. Either 'uuid' or 'match_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). uuid (str): match UUID (ex: '66ec2575-5ee4-d241-a1fc-d7ffeffb48b6'). match_id (int): match ID. Raises: Aoe2NetException: if the not one of 'uuid' or 'match_id' are provided. Returns: A MatchLobby validated object with the information of the specific match, including. \"\"\" if not uuid and not match_id : logger . error ( \"Missing one of 'uuid', 'match_id'.\" ) raise Aoe2NetException ( \"Either 'uuid' or 'match_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for single match query\" ) query_params = { \"game\" : game , \"uuid\" : uuid , \"match_id\" : match_id , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCH_ENDPOINT}'\" ) return MatchLobby ( ** processed_response ) def num_online ( self , game : str = \"aoe2de\" ) -> NumOnlineResponse : \"\"\" Number of players in game and an estimate of the number current playing multiplayer. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A NumOnlineResponse validated object with the app id and a list of PlayerCountTimePoint validated objects encapsulating estimated metrics at different timestamps ('steam', 'multiplayer', 'looking', 'in_game', 'multiplayer_1h' & 'multiplayer_24h'). \"\"\" logger . debug ( \"Preparing parameters for number of online players query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . NUMBER_ONLINE_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.NUMBER_ONLINE_ENDPOINT}'\" ) return NumOnlineResponse ( ** processed_response ) # ----- Helpers ----- # def _get_request_response_json ( session : requests . Session , url : str , params : Dict [ str , Any ] = None , timeout : Union [ float , Tuple [ float , float ]] = None , ) -> dict : \"\"\" Helper function to handle a GET request to an endpoint and return the response JSON content as a dictionary. Args: session (requests.Session): Session object to use, for connection pooling and performance. url (str): API endpoint to send the request to. params (dict): A dictionary of parameters for the GET request. Raises: Aoe2NetException: if the status code returned is not 200. Returns: The request's JSON response as a dictionary. \"\"\" default_headers = { \"content-type\" : \"application/json;charset=UTF-8\" } logger . debug ( f \"Sending GET request at '{url}'\" ) logger . trace ( f \"Parameters are: {str(params)}\" ) response = session . get ( url , params = params , headers = default_headers , timeout = timeout ) if response . status_code != 200 : logger . error ( f \"GET request at '{response.url}' returned a {response.status_code} status code\" ) raise Aoe2NetException ( f \"Expected status code 200 - got {response.status_code} instead.\" ) return response . json ()","title":"Module aoe2netwrapper.api"},{"location":"reference/aoe2netwrapper/api/#classes","text":"","title":"Classes"},{"location":"reference/aoe2netwrapper/api/#aoe2netapi","text":"class AoE2NetAPI ( timeout : Union [ float , Tuple [ float , float ]] = 5 ) View Source class AoE2NetAPI : \"\"\" The 'AoE2NetAPI' class is a client that encompasses the https://aoe2.net/#api API endpoints. Each method in this class corresponds name for name to an endpoint, and will do the work in querying then parsing and validating the response before returning it. \"\"\" API_BASE_URL : str = \"https://aoe2.net/api\" STRINGS_ENDPOINT : str = API_BASE_URL + \"/strings\" LEADERBOARD_ENDPOINT : str = API_BASE_URL + \"/leaderboard\" LOBBIES_ENDPOINT : str = API_BASE_URL + \"/lobbies\" LAST_MATCH_ENDPOINT : str = API_BASE_URL + \"/player/lastmatch\" MATCH_HISTORY_ENDPOINT : str = API_BASE_URL + \"/player/matches\" RATING_HISTORY_ENDPOINT : str = API_BASE_URL + \"/player/ratinghistory\" MATCHES_ENDPOINT : str = API_BASE_URL + \"/matches\" MATCH_ENDPOINT : str = API_BASE_URL + \"/match\" NUMBER_ONLINE_ENDPOINT : str = API_BASE_URL + \"/stats/players\" def __init__ ( self , timeout : Union [ float, Tuple[float, float ] ] = 5 ) : \"\"\"Creating a Session for connection pooling since we're always querying the same host.\"\"\" self . session = requests . Session () self . timeout = timeout def __repr__ ( self ) -> str : return f \"Client for <{self.API_BASE_URL}>\" def strings ( self , game : str = \"aoe2de\" ) -> StringsResponse : \"\"\" Requests a list of strings used by the API. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A StringsResponse validated object encapsulating the strings used by the API. \"\"\" logger . debug ( \"Preparing parameters for strings query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . STRINGS_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.STRINGS_ENDPOINT}'\" ) return StringsResponse ( ** processed_response ) def leaderboard ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , start : int = 1 , count : int = 10 , search : str = None , steam_id : int = None , profile_id : int = None , ) -> LeaderBoardResponse : \"\"\" Request the current leaderboards. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. start (int): Starting rank (ignored if search, steam_id, or profile_id are defined). Defaults to 1. count (int): Number of leaderboard entries to get (warning: must be 10000 or less). Defaults to 10. search (str): Optional. To perform the search for a specific player, from their name. steam_id (int): Optional. To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): Optional. To perform the search for a specific player, from their profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 10 000. Returns: A LeaderBoardResponse validated object with the different parameters used for the query, the total amount of hits, and the leaderboard as a list profile entries for each ranking. \"\"\" if count > 10 _000 : logger . error ( f \"'count' has to be 10000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) logger . debug ( \"Preparing parameters for leaderboard query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"start\" : start , \"count\" : count , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . LEADERBOARD_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LEADERBOARD_ENDPOINT}'\" ) return LeaderBoardResponse ( ** processed_response ) def lobbies ( self , game : str = \"aoe2de\" ) -> List [ MatchLobby ] : \"\"\" Request all open lobbies. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A list of MatchLobby valideted objects, each one encapsulating the data for a currently open lobby. \"\"\" logger . debug ( \"Preparing parameters for open lobbies query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . LOBBIES_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LOBBIES_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ] , processed_response ) def last_match ( self , game : str = \"aoe2de\" , steam_id : int = None , profile_id : int = None ) -> LastMatchResponse : \"\"\" Request the last match the player started playing, this will be the current match if they are still in game. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A LastMatchResponse validated object with the information of the game, including the following attributes: 'profile_id', 'steam_id', 'name', 'clan', 'country' and 'last_match'. \"\"\" if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for last match query\" ) query_params = { \"game\" : game , \"steam_id\" : steam_id , \"profile_id\" : profile_id } processed_response = _get_request_response_json ( session = self . session , url = self . LAST_MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LAST_MATCH_ENDPOINT}'\" ) return LastMatchResponse ( ** processed_response ) def match_history ( self , game : str = \"aoe2de\" , start : int = 0 , count : int = 10 , steam_id : int = None , profile_id : int = None , ) -> List [ MatchLobby ] : \"\"\" Request the match history for a player. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). start (int): starting match (0 is the most recent match). Defaults to 0. count (int): number of matches to get (must be 1000 or less). Defaults to 10. steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 1000. Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A list of MatchLobby validated objects, each one encapsulating the data for one of the player's previous matches. \"\"\" if count > 1 _000 : logger . error ( f \"'count' has to be 1000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for match history query\" ) query_params = { \"game\" : game , \"start\" : start , \"count\" : count , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCH_HISTORY_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCH_HISTORY_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ] , processed_response ) def rating_history ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , start : int = 0 , count : int = 20 , steam_id : int = None , profile_id : int = None , ) -> List [ RatingTimePoint ] : \"\"\" Requests the rating history for a player. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. start (int): starting match (0 is the most recent match). Defaults to 0. count (int): number of matches to get the rating for (must be 1000 or less). Defaults to 100. steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 10 000. Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A list of RatingTimePoint validated objects, each one encapsulating data at a certain point in time corresponding to a match played by the player, including the rating, timestamp of the match, streaks etc. \"\"\" if count > 10 _000 : logger . error ( f \"'count' has to be 10 000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for rating history query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"start\" : start , \"count\" : count , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . RATING_HISTORY_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.RATING_HISTORY_ENDPOINT}'\" ) return parse_obj_as ( List [ RatingTimePoint ] , processed_response ) def matches ( self , game : str = \"aoe2de\" , count : int = 10 , since : int = None ) -> List [ MatchLobby ] : \"\"\" Request matches after a specific time: the match history in an optionally given time window. If 'since' is not set, only the X amount of current past matches (specified by 'count') will be returned. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). count (int): number of matches to get (must be 1000 or less). Defaults to 10. since (int): only show matches starting after 'since' timestamp (epoch). Raises: Aoe2NetException: if the 'count' parameter exceeds 1000. Returns: A list of MatchLobby validated objects, each one encapsulating the data for one of the played matches during the time window queried for. \"\"\" if count > 1000 : logger . error ( f \"'count' has to be 1000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) logger . debug ( \"Preparing parameters for matches query\" ) query_params = { \"game\" : game , \"count\" : count , \"since\" : since , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCHES_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCHES_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ] , processed_response ) def match ( self , game : str = \"aoe2de\" , uuid : str = None , match_id : int = None ) -> MatchLobby : \"\"\" Request details about a match. Either 'uuid' or 'match_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). uuid (str): match UUID (ex: '66ec2575-5ee4-d241-a1fc-d7ffeffb48b6'). match_id (int): match ID. Raises: Aoe2NetException: if the not one of 'uuid' or 'match_id' are provided. Returns: A MatchLobby validated object with the information of the specific match, including. \"\"\" if not uuid and not match_id : logger . error ( \"Missing one of 'uuid', 'match_id'.\" ) raise Aoe2NetException ( \"Either 'uuid' or 'match_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for single match query\" ) query_params = { \"game\" : game , \"uuid\" : uuid , \"match_id\" : match_id , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCH_ENDPOINT}'\" ) return MatchLobby ( ** processed_response ) def num_online ( self , game : str = \"aoe2de\" ) -> NumOnlineResponse : \"\"\" Number of players in game and an estimate of the number current playing multiplayer. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A NumOnlineResponse validated object with the app id and a list of PlayerCountTimePoint validated objects encapsulating estimated metrics at different timestamps ('steam', 'multiplayer', 'looking', 'in_game', 'multiplayer_1h' & 'multiplayer_24h'). \"\"\" logger . debug ( \"Preparing parameters for number of online players query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . NUMBER_ONLINE_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.NUMBER_ONLINE_ENDPOINT}'\" ) return NumOnlineResponse ( ** processed_response )","title":"AoE2NetAPI"},{"location":"reference/aoe2netwrapper/api/#class-variables","text":"API_BASE_URL LAST_MATCH_ENDPOINT LEADERBOARD_ENDPOINT LOBBIES_ENDPOINT MATCHES_ENDPOINT MATCH_ENDPOINT MATCH_HISTORY_ENDPOINT NUMBER_ONLINE_ENDPOINT RATING_HISTORY_ENDPOINT STRINGS_ENDPOINT","title":"Class variables"},{"location":"reference/aoe2netwrapper/api/#methods","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/api/#last_match","text":"def last_match ( self , game : str = 'aoe2de' , steam_id : int = None , profile_id : int = None ) -> aoe2netwrapper . models . last_match . LastMatchResponse Request the last match the player started playing, this will be the current match if they are still in game. Either 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' steam_id int The player's steamID64 (ex: 76561199003184910). None profile_id int The player's profile ID (ex: 459658). None Returns: Type Description None A LastMatchResponse validated object with the information of the game, including the following attributes: 'profile_id', 'steam_id', 'name', 'clan', 'country' and 'last_match'. Raises: Type Description Aoe2NetException if the not one of 'steam_id' or 'profile_id' are provided. View Source def last_match ( self , game : str = \"aoe2de\" , steam_id : int = None , profile_id : int = None ) -> LastMatchResponse : \"\" \" Request the last match the player started playing , this will be the current match if they are still in game . Either 'steam_id' or 'profile_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). steam_id ( int ): The player ' s steamID64 ( ex : 76561199003184910 ). profile_id ( int ): The player ' s profile ID ( ex : 459658 ). Raises : Aoe2NetException : if the not one of 'steam_id' or 'profile_id' are provided . Returns : A LastMatchResponse validated object with the information of the game , including the following attributes : 'profile_id' , 'steam_id' , 'name' , 'clan' , 'country' and 'last_match' . \"\" \" if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for last match query\" ) query_params = { \"game\" : game , \"steam_id\" : steam_id , \"profile_id\" : profile_id } processed_response = _get_request_response_json ( session = self . session , url = self . LAST_MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LAST_MATCH_ENDPOINT}'\" ) return LastMatchResponse ( ** processed_response )","title":"last_match"},{"location":"reference/aoe2netwrapper/api/#leaderboard","text":"def leaderboard ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , start : int = 1 , count : int = 10 , search : str = None , steam_id : int = None , profile_id : int = None ) -> aoe2netwrapper . models . leaderboard . LeaderBoardResponse Request the current leaderboards. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None start int Starting rank (ignored if search, steam_id, or profile_id are defined). Defaults to 1. None count int Number of leaderboard entries to get (warning: must be 10000 or less). Defaults to 10. None search str Optional. To perform the search for a specific player, from their name. None steam_id int Optional. To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). None profile_id int Optional. To perform the search for a specific player, from their profile ID (ex: 459658). None Returns: Type Description None A LeaderBoardResponse validated object with the different parameters used for the query, the total amount of hits, and the leaderboard as a list profile entries for each ranking. Raises: Type Description Aoe2NetException if the 'count' parameter exceeds 10 000. View Source def leaderboard ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , start : int = 1 , count : int = 10 , search : str = None , steam_id : int = None , profile_id : int = None , ) -> LeaderBoardResponse : \"\" \" Request the current leaderboards . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). leaderboard_id ( int ): Leaderboard to extract the data for ( Unranked = 0 , 1 v1 Deathmatch = 1 , Team Deathmatch = 2 , 1 v1 Random Map = 3 , Team Random Map = 4 ). Defaults to 3 . start ( int ): Starting rank ( ignored if search , steam_id , or profile_id are defined ). Defaults to 1 . count ( int ): Number of leaderboard entries to get ( warning : must be 10000 or less ). Defaults to 10 . search ( str ): Optional . To perform the search for a specific player , from their name . steam_id ( int ): Optional . To perform the search for a specific player , from their steamID64 ( ex : 76561199003184910 ). profile_id ( int ): Optional . To perform the search for a specific player , from their profile ID ( ex : 459658 ). Raises : Aoe2NetException : if the 'count' parameter exceeds 10 000 . Returns : A LeaderBoardResponse validated object with the different parameters used for the query , the total amount of hits , and the leaderboard as a list profile entries for each ranking . \"\" \" if count > 10 _000 : logger . error ( f \"'count' has to be 10000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) logger . debug ( \"Preparing parameters for leaderboard query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"start\" : start , \"count\" : count , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . LEADERBOARD_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LEADERBOARD_ENDPOINT}'\" ) return LeaderBoardResponse ( ** processed_response )","title":"leaderboard"},{"location":"reference/aoe2netwrapper/api/#lobbies","text":"def lobbies ( self , game : str = 'aoe2de' ) -> List [ aoe2netwrapper . models . lobbies . MatchLobby ] Request all open lobbies. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' Returns: Type Description None A list of MatchLobby valideted objects, each one encapsulating the data for a currently open lobby. View Source def lobbies ( self , game : str = \"aoe2de\" ) -> List [ MatchLobby ] : \"\"\" Request all open lobbies. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). Returns: A list of MatchLobby valideted objects, each one encapsulating the data for a currently open lobby. \"\"\" logger . debug ( \"Preparing parameters for open lobbies query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . LOBBIES_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.LOBBIES_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ] , processed_response )","title":"lobbies"},{"location":"reference/aoe2netwrapper/api/#match","text":"def match ( self , game : str = 'aoe2de' , uuid : str = None , match_id : int = None ) -> aoe2netwrapper . models . lobbies . MatchLobby Request details about a match. Either 'uuid' or 'match_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' uuid str match UUID (ex: '66ec2575-5ee4-d241-a1fc-d7ffeffb48b6'). None match_id int match ID. None Returns: Type Description None A MatchLobby validated object with the information of the specific match, including. Raises: Type Description Aoe2NetException if the not one of 'uuid' or 'match_id' are provided. View Source def match ( self , game : str = \"aoe2de\" , uuid : str = None , match_id : int = None ) -> MatchLobby : \"\" \" Request details about a match . Either 'uuid' or 'match_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). uuid ( str ): match UUID ( ex : '66ec2575-5ee4-d241-a1fc-d7ffeffb48b6' ). match_id ( int ): match ID . Raises : Aoe2NetException : if the not one of 'uuid' or 'match_id' are provided . Returns : A MatchLobby validated object with the information of the specific match , including . \"\" \" if not uuid and not match_id : logger . error ( \"Missing one of 'uuid', 'match_id'.\" ) raise Aoe2NetException ( \"Either 'uuid' or 'match_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for single match query\" ) query_params = { \"game\" : game , \"uuid\" : uuid , \"match_id\" : match_id , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCH_ENDPOINT}'\" ) return MatchLobby ( ** processed_response )","title":"match"},{"location":"reference/aoe2netwrapper/api/#match_history","text":"def match_history ( self , game : str = 'aoe2de' , start : int = 0 , count : int = 10 , steam_id : int = None , profile_id : int = None ) -> List [ aoe2netwrapper . models . lobbies . MatchLobby ] Request the match history for a player. Either 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' start int starting match (0 is the most recent match). Defaults to 0. 0 count int number of matches to get (must be 1000 or less). Defaults to 10. 10 steam_id int The player's steamID64 (ex: 76561199003184910). None profile_id int The player's profile ID (ex: 459658). None Returns: Type Description None A list of MatchLobby validated objects, each one encapsulating the data for one of the player's previous matches. Raises: Type Description Aoe2NetException if the 'count' parameter exceeds 1000. Aoe2NetException if the not one of 'steam_id' or 'profile_id' are provided. View Source def match_history ( self , game : str = \"aoe2de\" , start : int = 0 , count : int = 10 , steam_id : int = None , profile_id : int = None , ) -> List [ MatchLobby ] : \"\"\" Request the match history for a player. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). start (int): starting match (0 is the most recent match). Defaults to 0. count (int): number of matches to get (must be 1000 or less). Defaults to 10. steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 1000. Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A list of MatchLobby validated objects, each one encapsulating the data for one of the player's previous matches. \"\"\" if count > 1 _000 : logger . error ( f \"'count' has to be 1000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for match history query\" ) query_params = { \"game\" : game , \"start\" : start , \"count\" : count , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCH_HISTORY_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCH_HISTORY_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ] , processed_response )","title":"match_history"},{"location":"reference/aoe2netwrapper/api/#matches","text":"def matches ( self , game : str = 'aoe2de' , count : int = 10 , since : int = None ) -> List [ aoe2netwrapper . models . lobbies . MatchLobby ] Request matches after a specific time: the match history in an optionally given time window. If 'since' is not set, only the X amount of current past matches (specified by 'count') will be returned. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' count int number of matches to get (must be 1000 or less). Defaults to 10. 10 since int only show matches starting after 'since' timestamp (epoch). None Returns: Type Description None A list of MatchLobby validated objects, each one encapsulating the data for one of the played matches during the time window queried for. Raises: Type Description Aoe2NetException if the 'count' parameter exceeds 1000. View Source def matches ( self , game : str = \"aoe2de\" , count : int = 10 , since : int = None ) -> List [ MatchLobby ] : \"\"\" Request matches after a specific time: the match history in an optionally given time window. If 'since' is not set, only the X amount of current past matches (specified by 'count') will be returned. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). count (int): number of matches to get (must be 1000 or less). Defaults to 10. since (int): only show matches starting after 'since' timestamp (epoch). Raises: Aoe2NetException: if the 'count' parameter exceeds 1000. Returns: A list of MatchLobby validated objects, each one encapsulating the data for one of the played matches during the time window queried for. \"\"\" if count > 1000 : logger . error ( f \"'count' has to be 1000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) logger . debug ( \"Preparing parameters for matches query\" ) query_params = { \"game\" : game , \"count\" : count , \"since\" : since , } processed_response = _get_request_response_json ( session = self . session , url = self . MATCHES_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.MATCHES_ENDPOINT}'\" ) return parse_obj_as ( List [ MatchLobby ] , processed_response )","title":"matches"},{"location":"reference/aoe2netwrapper/api/#num_online","text":"def num_online ( self , game : str = 'aoe2de' ) -> aoe2netwrapper . models . num_online . NumOnlineResponse Number of players in game and an estimate of the number current playing multiplayer. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' Returns: Type Description None A NumOnlineResponse validated object with the app id and a list of PlayerCountTimePoint validated objects encapsulating estimated metrics at different timestamps ('steam', 'multiplayer', 'looking', 'in_game', 'multiplayer_1h' & 'multiplayer_24h'). View Source def num_online ( self , game : str = \"aoe2de\" ) -> NumOnlineResponse : \"\" \" Number of players in game and an estimate of the number current playing multiplayer . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). Returns : A NumOnlineResponse validated object with the app id and a list of PlayerCountTimePoint validated objects encapsulating estimated metrics at different timestamps ( 'steam' , 'multiplayer' , 'looking' , 'in_game' , 'multiplayer_1h' & 'multiplayer_24h' ). \"\" \" logger . debug ( \"Preparing parameters for number of online players query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . NUMBER_ONLINE_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.NUMBER_ONLINE_ENDPOINT}'\" ) return NumOnlineResponse ( ** processed_response )","title":"num_online"},{"location":"reference/aoe2netwrapper/api/#rating_history","text":"def rating_history ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , start : int = 0 , count : int = 20 , steam_id : int = None , profile_id : int = None ) -> List [ aoe2netwrapper . models . rating_history . RatingTimePoint ] Requests the rating history for a player. Either 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None start int starting match (0 is the most recent match). Defaults to 0. 0 count int number of matches to get the rating for (must be 1000 or less). Defaults to 100. None steam_id int The player's steamID64 (ex: 76561199003184910). None profile_id int The player's profile ID (ex: 459658). None Returns: Type Description None A list of RatingTimePoint validated objects, each one encapsulating data at a certain point in time corresponding to a match played by the player, including the rating, timestamp of the match, streaks etc. Raises: Type Description Aoe2NetException if the 'count' parameter exceeds 10 000. Aoe2NetException if the not one of 'steam_id' or 'profile_id' are provided. View Source def rating_history ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , start : int = 0 , count : int = 20 , steam_id : int = None , profile_id : int = None , ) -> List [ RatingTimePoint ] : \"\"\" Requests the rating history for a player. Either 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. start (int): starting match (0 is the most recent match). Defaults to 0. count (int): number of matches to get the rating for (must be 1000 or less). Defaults to 100. steam_id (int): The player's steamID64 (ex: 76561199003184910). profile_id (int): The player's profile ID (ex: 459658). Raises: Aoe2NetException: if the 'count' parameter exceeds 10 000. Aoe2NetException: if the not one of 'steam_id' or 'profile_id' are provided. Returns: A list of RatingTimePoint validated objects, each one encapsulating data at a certain point in time corresponding to a match played by the player, including the rating, timestamp of the match, streaks etc. \"\"\" if count > 10 _000 : logger . error ( f \"'count' has to be 10 000 or less, but {count} was provided.\" ) raise Aoe2NetException ( \"Invalid value for parameter 'count'.\" ) if not steam_id and not profile_id : logger . error ( \"Missing one of 'steam_id', 'profile_id'.\" ) raise Aoe2NetException ( \"Either 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for rating history query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"start\" : start , \"count\" : count , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } processed_response = _get_request_response_json ( session = self . session , url = self . RATING_HISTORY_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.RATING_HISTORY_ENDPOINT}'\" ) return parse_obj_as ( List [ RatingTimePoint ] , processed_response )","title":"rating_history"},{"location":"reference/aoe2netwrapper/api/#strings","text":"def strings ( self , game : str = 'aoe2de' ) -> aoe2netwrapper . models . strings . StringsResponse Requests a list of strings used by the API. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' Returns: Type Description None A StringsResponse validated object encapsulating the strings used by the API. View Source def strings ( self , game : str = \"aoe2de\" ) -> StringsResponse : \"\" \" Requests a list of strings used by the API . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). Returns : A StringsResponse validated object encapsulating the strings used by the API . \"\" \" logger . debug ( \"Preparing parameters for strings query\" ) query_params = { \"game\" : game } processed_response = _get_request_response_json ( session = self . session , url = self . STRINGS_ENDPOINT , params = query_params , timeout = self . timeout , ) logger . trace ( f \"Validating response from '{self.STRINGS_ENDPOINT}'\" ) return StringsResponse ( ** processed_response )","title":"strings"},{"location":"reference/aoe2netwrapper/converters/","text":"Module aoe2netwrapper.converters aoe2netwrapper.converters This module implements a high-level class with static methods to convert result of AoENetAPI methods to pandas DataFrames. View Source \"\"\" aoe2netwrapper.converters ------------------------- This module implements a high-level class with static methods to convert result of AoENetAPI methods to pandas DataFrames. \"\"\" from typing import List from loguru import logger from aoe2netwrapper.models import ( LastMatchResponse , LeaderBoardResponse , MatchLobby , NumOnlineResponse , RatingTimePoint , StringsResponse , ) try : import pandas as pd except ImportError as error : logger . error ( \"User tried to use the 'converters' submodule without havinig installed the 'pandas' library.\" ) raise NotImplementedError ( \"The 'aoe2netwrapper.converters' module exports results to 'pandas.DataFrame' objects and \" \"needs the 'pandas' library installed to function.\" ) from error class Convert : \"\"\" This is a convenience class providing methods to convert the outputs from the AoE2NetAPI query methods into pandas DataFrame objects. Every method below is a staticmethod, so no object has to be instantiated. \"\"\" @staticmethod def strings ( strings_response : StringsResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().strings to a pandas DataFrame. Args: strings_response (StringsResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the StringsResponse, each column being the values for a 'string' used by the API, and the index being the ID numbers. Since this is the result of a join for many 'strings' that do not have the same amount of values, the resulting dataframe will contain NaNs wherever a given 'string' does not have a value for the given index ID. \"\"\" if not isinstance ( strings_response , StringsResponse ): logger . error ( \"Tried to use method with a parameter of type != StringsResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'StringsResponse'\" ) logger . debug ( \"Converting StringsResponse to DataFrame\" ) dframe = pd . DataFrame ( strings_response ) . transpose () dframe . columns = dframe . iloc [ 0 ] dframe = dframe . drop ( index = [ 0 ]) . reset_index ( drop = True ) dframe = dframe . drop ( columns = [ \"language\" ]) logger . trace ( \"Exporting each string attribute to its own dataframe and joining\" ) result = pd . DataFrame () for col in dframe . columns : intermediate = pd . DataFrame () intermediate [ col ] = dframe [ col ][ 0 ] intermediate [ \"id\" ] = intermediate [ col ] . apply ( lambda x : x . id ) intermediate [ col ] = intermediate [ col ] . apply ( lambda x : x . string ) result = result . join ( intermediate . set_index ( \"id\" ), how = \"outer\" ) return result @staticmethod def leaderboard ( leaderboard_response : LeaderBoardResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Args: leaderboard_response (LeaderBoardResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the LeaderBoardResponse, each row being an entry in the leaderboard. Top level attributes such as 'start' or 'total' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. \"\"\" if not isinstance ( leaderboard_response , LeaderBoardResponse ): logger . error ( \"Tried to use method with a parameter of type != LeaderBoardResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'LeaderBoardResponse'\" ) logger . debug ( \"Converting LeaderBoardResponse leaderboard to DataFrame\" ) dframe = pd . DataFrame ( leaderboard_response . leaderboard ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) logger . trace ( \"Inserting LeaderBoardResponse attributes as columns\" ) dframe [ \"leaderboard_id\" ] = leaderboard_response . leaderboard_id dframe [ \"start\" ] = leaderboard_response . start dframe [ \"count\" ] = leaderboard_response . count dframe [ \"total\" ] = leaderboard_response . total logger . trace ( \"Converting datetimes\" ) dframe [ \"last_match\" ] = pd . to_datetime ( dframe [ \"last_match\" ], unit = \"s\" ) dframe [ \"last_match_time\" ] = pd . to_datetime ( dframe [ \"last_match_time\" ], unit = \"s\" ) return dframe @staticmethod def lobbies ( lobbies_response : List [ MatchLobby ]) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().lobbies to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: lobbies_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements.. \"\"\" if not isinstance ( lobbies_response , list ): # move list to List[MatchLobby] when supporting > 3.9 logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Lobbies response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe ( match_lobby ) for match_lobby in lobbies_response ] return pd . concat ( unfolded_lobbies ) . reset_index ( drop = True ) @staticmethod def last_match ( last_match_response : LastMatchResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().last_match to a pandas DataFrame. There is not much use to this as the DataFrame will only have one row, but the method is provided nonetheless in case users want to concatenate several of these results in a DataFrame. Args: last_match_response (LastMatchResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of LastMatchResponse attributes. Beware: the 'players' column is directly the content of the 'LastMatchResponse.last_match.players' attribute and as such holds a list of LobbyMember objects. \"\"\" if not isinstance ( last_match_response , LastMatchResponse ): logger . error ( \"Tried to use method with a parameter of type != LastMatchResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'LastMatchResponse'\" ) logger . debug ( \"Converting LastMatchResponse last_match to DataFrame\" ) dframe = pd . DataFrame ( last_match_response . last_match ) . transpose () dframe . columns = dframe . iloc [ 0 ] dframe = dframe . drop ( 0 ) . reset_index () logger . trace ( \"Inserting LastMatchResponse attributes as columns\" ) dframe [ \"profile_id\" ] = last_match_response . profile_id dframe [ \"steam_id\" ] = last_match_response . steam_id dframe [ \"name\" ] = last_match_response . name dframe [ \"country\" ] = last_match_response . country return dframe @staticmethod def match_history ( match_history_response : List [ MatchLobby ]) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: match_history_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements. \"\"\" # move list to List[MatchLobby] when supporting > 3.9 if not isinstance ( match_history_response , list ): logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Match History response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe ( match_lobby ) for match_lobby in match_history_response ] return pd . concat ( unfolded_lobbies ) . reset_index ( drop = True ) @staticmethod def rating_history ( rating_history_response : List [ RatingTimePoint ]) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Args: rating_history_response (List[RatingTimePoint]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of RatingTimePoint elements, each row being the information from one RatingTimePoint in the list. Timestamps are converted to datetime objects. \"\"\" # move list to List[RatingTimePoint] when supporting > 3.9 if not isinstance ( rating_history_response , list ): logger . error ( \"Tried to use method with a parameter of type != List[RatingTimePoint]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[RatingTimePoint]'\" ) logger . debug ( \"Converting Rating History rsponse to DataFrame\" ) dframe = pd . DataFrame ( rating_history_response ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) logger . trace ( \"Converting timestamps to datetime objects\" ) dframe [ \"time\" ] = pd . to_datetime ( dframe [ \"timestamp\" ], unit = \"s\" ) dframe = dframe . drop ( columns = [ \"timestamp\" ]) return dframe @staticmethod def matches ( matches_response : List [ MatchLobby ]) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: matches_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements. \"\"\" if not isinstance ( matches_response , list ): # move list to List[MatchLobby] when supporting > 3.9 logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Match History response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe ( match_lobby ) for match_lobby in matches_response ] return pd . concat ( unfolded_lobbies ) . reset_index ( drop = True ) @staticmethod def match ( match_response : MatchLobby ) -> pd . DataFrame : \"\"\" Convert the content of a MatchLobby to a pandas DataFrame. The resulting DataFrame will have as many rows as there are players in the lobby, and all global attributes will be broadcasted to columns of the same length, making them duplicates. Args: match_response (MatchLobby): a MatchLobby object. Returns: A pandas DataFrame from the MatchLobby attributes, each row being global information from the MatchLobby as well as one of the players in the lobby. \"\"\" return _unfold_match_lobby_to_dataframe ( match_response ) @staticmethod def num_online ( num_online_response : NumOnlineResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().num_online to a pandas DataFrame. Args: num_online_response (NumOnlineResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the NumOnlineResponse, each row being an entry in the leaderboard. Top level attributes such as 'app_id' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. \"\"\" if not isinstance ( num_online_response , NumOnlineResponse ): logger . error ( \"Tried to use method with a parameter of type != NumOnlineResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'NumOnlineResponse'\" ) logger . debug ( \"Converting NumOnlineResponse to DataFrame\" ) dframe = pd . DataFrame ( num_online_response . dict ()) logger . trace ( \"Exporting 'player_stats' attribute contents to columns\" ) dframe [ \"time\" ] = dframe . player_stats . apply ( lambda x : x [ \"time\" ]) . apply ( pd . to_datetime ) dframe [ \"steam\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"steam\" ]) dframe [ \"looking\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"looking\" ]) dframe [ \"in_game\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"in_game\" ]) dframe [ \"multiplayer\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer\" ]) dframe [ \"multiplayer_1h\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer_1h\" ]) dframe [ \"multiplayer_24h\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer_24h\" ]) logger . trace ( \"Removing 'player_stats' column to avoid nested & duplicate data\" ) dframe = dframe . drop ( columns = [ \"player_stats\" ]) return dframe # ----- Helpers ----- # def _export_tuple_elements_to_column_values_format ( dataframe : pd . DataFrame ) -> pd . DataFrame : \"\"\" Take in a pandas DataFrame with simple int values as columns, and elements being a tuple of (attribute_name, value) and cast it to have the attribute_name as column names, and the values as values. The original columns will be dropped in the process. Args: dataframe (pd.DataFrame): your pandas DataFrame. Returns: The refactored pandas DataFrame. \"\"\" dframe = dataframe . copy ( deep = True ) logger . trace ( \"Exporting attributes to columns and removing duplicate data\" ) for _ , col_index in enumerate ( dframe . columns ): attribute = dframe [ col_index ][ 0 ][ 0 ] dframe [ attribute ] = dframe [ col_index ] . apply ( lambda x : x [ 1 ]) dframe = dframe . drop ( columns = [ col_index ]) return dframe def _unfold_match_lobby_to_dataframe ( match_lobby : MatchLobby ) -> pd . DataFrame : \"\"\" Convert the content of a MatchLobby to a pandas DataFrame. The resulting DataFrame will have as many rows as there are players in the lobby, and all global attributes will be broadcasted to columns of the same length, making them duplicates. Args: match_lobby (MatchLobby): a MatchLobby object. Returns: A pandas DataFrame from the MatchLobby attributes, each row being global information from the MatchLobby as well as one of the players in the lobby. \"\"\" if not isinstance ( match_lobby , MatchLobby ): logger . error ( \"Tried to use method with a parameter of type != MatchLobby\" ) raise TypeError ( \"Provided parameter should be an instance of 'MatchLobby'\" ) logger . trace ( \"Unfolding MatchLobby.players contents to DataFrame\" ) dframe = pd . DataFrame ( match_lobby . players ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) dframe = dframe . rename ( columns = { \"name\" : \"player\" }) logger . trace ( \"Broadcasting global MatchLobby attributes\" ) attributes_df = pd . DataFrame () for attribute , value in match_lobby . dict () . items (): if attribute != \"players\" : attributes_df [ attribute ] = [ value ] * len ( dframe ) dframe = attributes_df . join ( dframe , how = \"outer\" ) logger . trace ( \"Converting timestamps to datetime objects\" ) dframe [ \"opened\" ] = pd . to_datetime ( dframe [ \"opened\" ], unit = \"s\" ) dframe [ \"started\" ] = pd . to_datetime ( dframe [ \"started\" ], unit = \"s\" ) dframe [ \"finished\" ] = pd . to_datetime ( dframe [ \"finished\" ], unit = \"s\" ) return dframe Classes Convert class Convert ( / , * args , ** kwargs ) View Source class Convert : \"\"\" This is a convenience class providing methods to convert the outputs from the AoE2NetAPI query methods into pandas DataFrame objects. Every method below is a staticmethod, so no object has to be instantiated. \"\"\" @staticmethod def strings ( strings_response : StringsResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().strings to a pandas DataFrame. Args: strings_response (StringsResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the StringsResponse, each column being the values for a 'string' used by the API, and the index being the ID numbers. Since this is the result of a join for many 'strings' that do not have the same amount of values, the resulting dataframe will contain NaNs wherever a given 'string' does not have a value for the given index ID. \"\"\" if not isinstance ( strings_response , StringsResponse ) : logger . error ( \"Tried to use method with a parameter of type != StringsResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'StringsResponse'\" ) logger . debug ( \"Converting StringsResponse to DataFrame\" ) dframe = pd . DataFrame ( strings_response ). transpose () dframe . columns = dframe . iloc [ 0 ] dframe = dframe . drop ( index =[ 0 ] ). reset_index ( drop = True ) dframe = dframe . drop ( columns =[ \"language\" ] ) logger . trace ( \"Exporting each string attribute to its own dataframe and joining\" ) result = pd . DataFrame () for col in dframe . columns : intermediate = pd . DataFrame () intermediate [ col ] = dframe [ col ][ 0 ] intermediate [ \"id\" ] = intermediate [ col ] . apply ( lambda x : x . id ) intermediate [ col ] = intermediate [ col ] . apply ( lambda x : x . string ) result = result . join ( intermediate . set_index ( \"id\" ), how = \"outer\" ) return result @staticmethod def leaderboard ( leaderboard_response : LeaderBoardResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Args: leaderboard_response (LeaderBoardResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the LeaderBoardResponse, each row being an entry in the leaderboard. Top level attributes such as 'start' or 'total' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. \"\"\" if not isinstance ( leaderboard_response , LeaderBoardResponse ) : logger . error ( \"Tried to use method with a parameter of type != LeaderBoardResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'LeaderBoardResponse'\" ) logger . debug ( \"Converting LeaderBoardResponse leaderboard to DataFrame\" ) dframe = pd . DataFrame ( leaderboard_response . leaderboard ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) logger . trace ( \"Inserting LeaderBoardResponse attributes as columns\" ) dframe [ \"leaderboard_id\" ] = leaderboard_response . leaderboard_id dframe [ \"start\" ] = leaderboard_response . start dframe [ \"count\" ] = leaderboard_response . count dframe [ \"total\" ] = leaderboard_response . total logger . trace ( \"Converting datetimes\" ) dframe [ \"last_match\" ] = pd . to_datetime ( dframe [ \"last_match\" ] , unit = \"s\" ) dframe [ \"last_match_time\" ] = pd . to_datetime ( dframe [ \"last_match_time\" ] , unit = \"s\" ) return dframe @staticmethod def lobbies ( lobbies_response : List [ MatchLobby ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().lobbies to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: lobbies_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements.. \"\"\" if not isinstance ( lobbies_response , list ) : # move list to List [ MatchLobby ] when supporting > 3.9 logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Lobbies response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe(match_lobby) for match_lobby in lobbies_response ] return pd . concat ( unfolded_lobbies ). reset_index ( drop = True ) @staticmethod def last_match ( last_match_response : LastMatchResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().last_match to a pandas DataFrame. There is not much use to this as the DataFrame will only have one row, but the method is provided nonetheless in case users want to concatenate several of these results in a DataFrame. Args: last_match_response (LastMatchResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of LastMatchResponse attributes. Beware: the 'players' column is directly the content of the 'LastMatchResponse.last_match.players' attribute and as such holds a list of LobbyMember objects. \"\"\" if not isinstance ( last_match_response , LastMatchResponse ) : logger . error ( \"Tried to use method with a parameter of type != LastMatchResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'LastMatchResponse'\" ) logger . debug ( \"Converting LastMatchResponse last_match to DataFrame\" ) dframe = pd . DataFrame ( last_match_response . last_match ). transpose () dframe . columns = dframe . iloc [ 0 ] dframe = dframe . drop ( 0 ). reset_index () logger . trace ( \"Inserting LastMatchResponse attributes as columns\" ) dframe [ \"profile_id\" ] = last_match_response . profile_id dframe [ \"steam_id\" ] = last_match_response . steam_id dframe [ \"name\" ] = last_match_response . name dframe [ \"country\" ] = last_match_response . country return dframe @staticmethod def match_history ( match_history_response : List [ MatchLobby ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: match_history_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements. \"\"\" # move list to List [ MatchLobby ] when supporting > 3.9 if not isinstance ( match_history_response , list ) : logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Match History response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe(match_lobby) for match_lobby in match_history_response ] return pd . concat ( unfolded_lobbies ). reset_index ( drop = True ) @staticmethod def rating_history ( rating_history_response : List [ RatingTimePoint ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Args: rating_history_response (List[RatingTimePoint]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of RatingTimePoint elements, each row being the information from one RatingTimePoint in the list. Timestamps are converted to datetime objects. \"\"\" # move list to List [ RatingTimePoint ] when supporting > 3.9 if not isinstance ( rating_history_response , list ) : logger . error ( \"Tried to use method with a parameter of type != List[RatingTimePoint]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[RatingTimePoint]'\" ) logger . debug ( \"Converting Rating History rsponse to DataFrame\" ) dframe = pd . DataFrame ( rating_history_response ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) logger . trace ( \"Converting timestamps to datetime objects\" ) dframe [ \"time\" ] = pd . to_datetime ( dframe [ \"timestamp\" ] , unit = \"s\" ) dframe = dframe . drop ( columns =[ \"timestamp\" ] ) return dframe @staticmethod def matches ( matches_response : List [ MatchLobby ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: matches_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements. \"\"\" if not isinstance ( matches_response , list ) : # move list to List [ MatchLobby ] when supporting > 3.9 logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Match History response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe(match_lobby) for match_lobby in matches_response ] return pd . concat ( unfolded_lobbies ). reset_index ( drop = True ) @staticmethod def match ( match_response : MatchLobby ) -> pd . DataFrame : \"\"\" Convert the content of a MatchLobby to a pandas DataFrame. The resulting DataFrame will have as many rows as there are players in the lobby, and all global attributes will be broadcasted to columns of the same length, making them duplicates. Args: match_response (MatchLobby): a MatchLobby object. Returns: A pandas DataFrame from the MatchLobby attributes, each row being global information from the MatchLobby as well as one of the players in the lobby. \"\"\" return _unfold_match_lobby_to_dataframe ( match_response ) @staticmethod def num_online ( num_online_response : NumOnlineResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().num_online to a pandas DataFrame. Args: num_online_response (NumOnlineResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the NumOnlineResponse, each row being an entry in the leaderboard. Top level attributes such as 'app_id' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. \"\"\" if not isinstance ( num_online_response , NumOnlineResponse ) : logger . error ( \"Tried to use method with a parameter of type != NumOnlineResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'NumOnlineResponse'\" ) logger . debug ( \"Converting NumOnlineResponse to DataFrame\" ) dframe = pd . DataFrame ( num_online_response . dict ()) logger . trace ( \"Exporting 'player_stats' attribute contents to columns\" ) dframe [ \"time\" ] = dframe . player_stats . apply ( lambda x : x [ \"time\" ] ). apply ( pd . to_datetime ) dframe [ \"steam\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"steam\" ] ) dframe [ \"looking\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"looking\" ] ) dframe [ \"in_game\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"in_game\" ] ) dframe [ \"multiplayer\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer\" ] ) dframe [ \"multiplayer_1h\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer_1h\" ] ) dframe [ \"multiplayer_24h\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer_24h\" ] ) logger . trace ( \"Removing 'player_stats' column to avoid nested & duplicate data\" ) dframe = dframe . drop ( columns =[ \"player_stats\" ] ) return dframe Static methods last_match def last_match ( last_match_response : aoe2netwrapper . models . last_match . LastMatchResponse ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().last_match to a pandas DataFrame. There is not much use to this as the DataFrame will only have one row, but the method is provided nonetheless in case users want to concatenate several of these results in a DataFrame. Parameters: Name Type Description Default last_match_response LastMatchResponse the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the list of LastMatchResponse attributes. Beware: the 'players' column is directly the content of the 'LastMatchResponse.last_match.players' attribute and as such holds a list of LobbyMember objects. View Source @staticmethod def last_match ( last_match_response : LastMatchResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().last_match to a pandas DataFrame. There is not much use to this as the DataFrame will only have one row, but the method is provided nonetheless in case users want to concatenate several of these results in a DataFrame. Args: last_match_response (LastMatchResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of LastMatchResponse attributes. Beware: the 'players' column is directly the content of the 'LastMatchResponse.last_match.players' attribute and as such holds a list of LobbyMember objects. \"\"\" if not isinstance ( last_match_response , LastMatchResponse ) : logger . error ( \"Tried to use method with a parameter of type != LastMatchResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'LastMatchResponse'\" ) logger . debug ( \"Converting LastMatchResponse last_match to DataFrame\" ) dframe = pd . DataFrame ( last_match_response . last_match ). transpose () dframe . columns = dframe . iloc [ 0 ] dframe = dframe . drop ( 0 ). reset_index () logger . trace ( \"Inserting LastMatchResponse attributes as columns\" ) dframe [ \"profile_id\" ] = last_match_response . profile_id dframe [ \"steam_id\" ] = last_match_response . steam_id dframe [ \"name\" ] = last_match_response . name dframe [ \"country\" ] = last_match_response . country return dframe leaderboard def leaderboard ( leaderboard_response : aoe2netwrapper . models . leaderboard . LeaderBoardResponse ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Parameters: Name Type Description Default leaderboard_response LeaderBoardResponse the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the LeaderBoardResponse, each row being an entry in the leaderboard. Top level attributes such as 'start' or 'total' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. View Source @ staticmethod def leaderboard ( leaderboard_response : LeaderBoardResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Args: leaderboard_response (LeaderBoardResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the LeaderBoardResponse, each row being an entry in the leaderboard. Top level attributes such as 'start' or 'total' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. \"\"\" if not isinstance ( leaderboard_response , LeaderBoardResponse ): logger . error ( \"Tried to use method with a parameter of type != LeaderBoardResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'LeaderBoardResponse'\" ) logger . debug ( \"Converting LeaderBoardResponse leaderboard to DataFrame\" ) dframe = pd . DataFrame ( leaderboard_response . leaderboard ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) logger . trace ( \"Inserting LeaderBoardResponse attributes as columns\" ) dframe [ \"leaderboard_id\" ] = leaderboard_response . leaderboard_id dframe [ \"start\" ] = leaderboard_response . start dframe [ \"count\" ] = leaderboard_response . count dframe [ \"total\" ] = leaderboard_response . total logger . trace ( \"Converting datetimes\" ) dframe [ \"last_match\" ] = pd . to_datetime ( dframe [ \"last_match\" ], unit = \"s\" ) dframe [ \"last_match_time\" ] = pd . to_datetime ( dframe [ \"last_match_time\" ], unit = \"s\" ) return dframe lobbies def lobbies ( lobbies_response : List [ aoe2netwrapper . models . lobbies . MatchLobby ] ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().lobbies to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Parameters: Name Type Description Default lobbies_response List[MatchLobby] the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the list of MatchLobby elements.. View Source @staticmethod def lobbies ( lobbies_response : List [ MatchLobby ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().lobbies to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: lobbies_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements.. \"\"\" if not isinstance ( lobbies_response , list ) : # move list to List [ MatchLobby ] when supporting > 3.9 logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Lobbies response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe(match_lobby) for match_lobby in lobbies_response ] return pd . concat ( unfolded_lobbies ). reset_index ( drop = True ) match def match ( match_response : aoe2netwrapper . models . lobbies . MatchLobby ) -> pandas . core . frame . DataFrame Convert the content of a MatchLobby to a pandas DataFrame. The resulting DataFrame will have as many rows as there are players in the lobby, and all global attributes will be broadcasted to columns of the same length, making them duplicates. Parameters: Name Type Description Default match_response MatchLobby a MatchLobby object. None Returns: Type Description None A pandas DataFrame from the MatchLobby attributes, each row being global information from the MatchLobby as well as one of the players in the lobby. View Source @staticmethod def match ( match_response : MatchLobby ) -> pd . DataFrame : \"\"\" Convert the content of a MatchLobby to a pandas DataFrame. The resulting DataFrame will have as many rows as there are players in the lobby, and all global attributes will be broadcasted to columns of the same length, making them duplicates. Args: match_response (MatchLobby): a MatchLobby object. Returns: A pandas DataFrame from the MatchLobby attributes, each row being global information from the MatchLobby as well as one of the players in the lobby. \"\"\" return _unfold_match_lobby_to_dataframe ( match_response ) match_history def match_history ( match_history_response : List [ aoe2netwrapper . models . lobbies . MatchLobby ] ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Parameters: Name Type Description Default match_history_response List[MatchLobby] the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the list of MatchLobby elements. View Source @staticmethod def match_history ( match_history_response : List [ MatchLobby ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: match_history_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements. \"\"\" # move list to List [ MatchLobby ] when supporting > 3.9 if not isinstance ( match_history_response , list ) : logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Match History response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe(match_lobby) for match_lobby in match_history_response ] return pd . concat ( unfolded_lobbies ). reset_index ( drop = True ) matches def matches ( matches_response : List [ aoe2netwrapper . models . lobbies . MatchLobby ] ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Parameters: Name Type Description Default matches_response List[MatchLobby] the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the list of MatchLobby elements. View Source @staticmethod def matches ( matches_response : List [ MatchLobby ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: matches_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements. \"\"\" if not isinstance ( matches_response , list ) : # move list to List [ MatchLobby ] when supporting > 3.9 logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Match History response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe(match_lobby) for match_lobby in matches_response ] return pd . concat ( unfolded_lobbies ). reset_index ( drop = True ) num_online def num_online ( num_online_response : aoe2netwrapper . models . num_online . NumOnlineResponse ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().num_online to a pandas DataFrame. Parameters: Name Type Description Default num_online_response NumOnlineResponse the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the NumOnlineResponse, each row being an entry in the leaderboard. Top level attributes such as 'app_id' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. View Source @staticmethod def num_online ( num_online_response : NumOnlineResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().num_online to a pandas DataFrame. Args: num_online_response (NumOnlineResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the NumOnlineResponse, each row being an entry in the leaderboard. Top level attributes such as 'app_id' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. \"\"\" if not isinstance ( num_online_response , NumOnlineResponse ) : logger . error ( \"Tried to use method with a parameter of type != NumOnlineResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'NumOnlineResponse'\" ) logger . debug ( \"Converting NumOnlineResponse to DataFrame\" ) dframe = pd . DataFrame ( num_online_response . dict ()) logger . trace ( \"Exporting 'player_stats' attribute contents to columns\" ) dframe [ \"time\" ] = dframe . player_stats . apply ( lambda x : x [ \"time\" ] ). apply ( pd . to_datetime ) dframe [ \"steam\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"steam\" ] ) dframe [ \"looking\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"looking\" ] ) dframe [ \"in_game\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"in_game\" ] ) dframe [ \"multiplayer\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer\" ] ) dframe [ \"multiplayer_1h\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer_1h\" ] ) dframe [ \"multiplayer_24h\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer_24h\" ] ) logger . trace ( \"Removing 'player_stats' column to avoid nested & duplicate data\" ) dframe = dframe . drop ( columns =[ \"player_stats\" ] ) return dframe rating_history def rating_history ( rating_history_response : List [ aoe2netwrapper . models . rating_history . RatingTimePoint ] ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Parameters: Name Type Description Default rating_history_response List[RatingTimePoint] the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the list of RatingTimePoint elements, each row being the information from one RatingTimePoint in the list. Timestamps are converted to datetime objects. View Source @staticmethod def rating_history ( rating_history_response : List [ RatingTimePoint ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Args: rating_history_response (List[RatingTimePoint]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of RatingTimePoint elements, each row being the information from one RatingTimePoint in the list. Timestamps are converted to datetime objects. \"\"\" # move list to List [ RatingTimePoint ] when supporting > 3.9 if not isinstance ( rating_history_response , list ) : logger . error ( \"Tried to use method with a parameter of type != List[RatingTimePoint]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[RatingTimePoint]'\" ) logger . debug ( \"Converting Rating History rsponse to DataFrame\" ) dframe = pd . DataFrame ( rating_history_response ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) logger . trace ( \"Converting timestamps to datetime objects\" ) dframe [ \"time\" ] = pd . to_datetime ( dframe [ \"timestamp\" ] , unit = \"s\" ) dframe = dframe . drop ( columns =[ \"timestamp\" ] ) return dframe strings def strings ( strings_response : aoe2netwrapper . models . strings . StringsResponse ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().strings to a pandas DataFrame. Parameters: Name Type Description Default strings_response StringsResponse the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the StringsResponse, each column being the values for a 'string' used by the API, and the index being the ID numbers. Since this is the result of a join for many 'strings' that do not have the same amount of values, the resulting dataframe will contain NaNs wherever a given 'string' does not have a value for the given index ID. View Source @staticmethod def strings ( strings_response : StringsResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().strings to a pandas DataFrame. Args: strings_response (StringsResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the StringsResponse, each column being the values for a 'string' used by the API, and the index being the ID numbers. Since this is the result of a join for many 'strings' that do not have the same amount of values, the resulting dataframe will contain NaNs wherever a given 'string' does not have a value for the given index ID. \"\"\" if not isinstance ( strings_response , StringsResponse ) : logger . error ( \"Tried to use method with a parameter of type != StringsResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'StringsResponse'\" ) logger . debug ( \"Converting StringsResponse to DataFrame\" ) dframe = pd . DataFrame ( strings_response ). transpose () dframe . columns = dframe . iloc [ 0 ] dframe = dframe . drop ( index =[ 0 ] ). reset_index ( drop = True ) dframe = dframe . drop ( columns =[ \"language\" ] ) logger . trace ( \"Exporting each string attribute to its own dataframe and joining\" ) result = pd . DataFrame () for col in dframe . columns : intermediate = pd . DataFrame () intermediate [ col ] = dframe [ col ][ 0 ] intermediate [ \"id\" ] = intermediate [ col ] . apply ( lambda x : x . id ) intermediate [ col ] = intermediate [ col ] . apply ( lambda x : x . string ) result = result . join ( intermediate . set_index ( \"id\" ), how = \"outer\" ) return result","title":"Converters"},{"location":"reference/aoe2netwrapper/converters/#module-aoe2netwrapperconverters","text":"aoe2netwrapper.converters This module implements a high-level class with static methods to convert result of AoENetAPI methods to pandas DataFrames. View Source \"\"\" aoe2netwrapper.converters ------------------------- This module implements a high-level class with static methods to convert result of AoENetAPI methods to pandas DataFrames. \"\"\" from typing import List from loguru import logger from aoe2netwrapper.models import ( LastMatchResponse , LeaderBoardResponse , MatchLobby , NumOnlineResponse , RatingTimePoint , StringsResponse , ) try : import pandas as pd except ImportError as error : logger . error ( \"User tried to use the 'converters' submodule without havinig installed the 'pandas' library.\" ) raise NotImplementedError ( \"The 'aoe2netwrapper.converters' module exports results to 'pandas.DataFrame' objects and \" \"needs the 'pandas' library installed to function.\" ) from error class Convert : \"\"\" This is a convenience class providing methods to convert the outputs from the AoE2NetAPI query methods into pandas DataFrame objects. Every method below is a staticmethod, so no object has to be instantiated. \"\"\" @staticmethod def strings ( strings_response : StringsResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().strings to a pandas DataFrame. Args: strings_response (StringsResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the StringsResponse, each column being the values for a 'string' used by the API, and the index being the ID numbers. Since this is the result of a join for many 'strings' that do not have the same amount of values, the resulting dataframe will contain NaNs wherever a given 'string' does not have a value for the given index ID. \"\"\" if not isinstance ( strings_response , StringsResponse ): logger . error ( \"Tried to use method with a parameter of type != StringsResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'StringsResponse'\" ) logger . debug ( \"Converting StringsResponse to DataFrame\" ) dframe = pd . DataFrame ( strings_response ) . transpose () dframe . columns = dframe . iloc [ 0 ] dframe = dframe . drop ( index = [ 0 ]) . reset_index ( drop = True ) dframe = dframe . drop ( columns = [ \"language\" ]) logger . trace ( \"Exporting each string attribute to its own dataframe and joining\" ) result = pd . DataFrame () for col in dframe . columns : intermediate = pd . DataFrame () intermediate [ col ] = dframe [ col ][ 0 ] intermediate [ \"id\" ] = intermediate [ col ] . apply ( lambda x : x . id ) intermediate [ col ] = intermediate [ col ] . apply ( lambda x : x . string ) result = result . join ( intermediate . set_index ( \"id\" ), how = \"outer\" ) return result @staticmethod def leaderboard ( leaderboard_response : LeaderBoardResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Args: leaderboard_response (LeaderBoardResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the LeaderBoardResponse, each row being an entry in the leaderboard. Top level attributes such as 'start' or 'total' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. \"\"\" if not isinstance ( leaderboard_response , LeaderBoardResponse ): logger . error ( \"Tried to use method with a parameter of type != LeaderBoardResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'LeaderBoardResponse'\" ) logger . debug ( \"Converting LeaderBoardResponse leaderboard to DataFrame\" ) dframe = pd . DataFrame ( leaderboard_response . leaderboard ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) logger . trace ( \"Inserting LeaderBoardResponse attributes as columns\" ) dframe [ \"leaderboard_id\" ] = leaderboard_response . leaderboard_id dframe [ \"start\" ] = leaderboard_response . start dframe [ \"count\" ] = leaderboard_response . count dframe [ \"total\" ] = leaderboard_response . total logger . trace ( \"Converting datetimes\" ) dframe [ \"last_match\" ] = pd . to_datetime ( dframe [ \"last_match\" ], unit = \"s\" ) dframe [ \"last_match_time\" ] = pd . to_datetime ( dframe [ \"last_match_time\" ], unit = \"s\" ) return dframe @staticmethod def lobbies ( lobbies_response : List [ MatchLobby ]) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().lobbies to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: lobbies_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements.. \"\"\" if not isinstance ( lobbies_response , list ): # move list to List[MatchLobby] when supporting > 3.9 logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Lobbies response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe ( match_lobby ) for match_lobby in lobbies_response ] return pd . concat ( unfolded_lobbies ) . reset_index ( drop = True ) @staticmethod def last_match ( last_match_response : LastMatchResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().last_match to a pandas DataFrame. There is not much use to this as the DataFrame will only have one row, but the method is provided nonetheless in case users want to concatenate several of these results in a DataFrame. Args: last_match_response (LastMatchResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of LastMatchResponse attributes. Beware: the 'players' column is directly the content of the 'LastMatchResponse.last_match.players' attribute and as such holds a list of LobbyMember objects. \"\"\" if not isinstance ( last_match_response , LastMatchResponse ): logger . error ( \"Tried to use method with a parameter of type != LastMatchResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'LastMatchResponse'\" ) logger . debug ( \"Converting LastMatchResponse last_match to DataFrame\" ) dframe = pd . DataFrame ( last_match_response . last_match ) . transpose () dframe . columns = dframe . iloc [ 0 ] dframe = dframe . drop ( 0 ) . reset_index () logger . trace ( \"Inserting LastMatchResponse attributes as columns\" ) dframe [ \"profile_id\" ] = last_match_response . profile_id dframe [ \"steam_id\" ] = last_match_response . steam_id dframe [ \"name\" ] = last_match_response . name dframe [ \"country\" ] = last_match_response . country return dframe @staticmethod def match_history ( match_history_response : List [ MatchLobby ]) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: match_history_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements. \"\"\" # move list to List[MatchLobby] when supporting > 3.9 if not isinstance ( match_history_response , list ): logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Match History response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe ( match_lobby ) for match_lobby in match_history_response ] return pd . concat ( unfolded_lobbies ) . reset_index ( drop = True ) @staticmethod def rating_history ( rating_history_response : List [ RatingTimePoint ]) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Args: rating_history_response (List[RatingTimePoint]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of RatingTimePoint elements, each row being the information from one RatingTimePoint in the list. Timestamps are converted to datetime objects. \"\"\" # move list to List[RatingTimePoint] when supporting > 3.9 if not isinstance ( rating_history_response , list ): logger . error ( \"Tried to use method with a parameter of type != List[RatingTimePoint]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[RatingTimePoint]'\" ) logger . debug ( \"Converting Rating History rsponse to DataFrame\" ) dframe = pd . DataFrame ( rating_history_response ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) logger . trace ( \"Converting timestamps to datetime objects\" ) dframe [ \"time\" ] = pd . to_datetime ( dframe [ \"timestamp\" ], unit = \"s\" ) dframe = dframe . drop ( columns = [ \"timestamp\" ]) return dframe @staticmethod def matches ( matches_response : List [ MatchLobby ]) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: matches_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements. \"\"\" if not isinstance ( matches_response , list ): # move list to List[MatchLobby] when supporting > 3.9 logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Match History response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe ( match_lobby ) for match_lobby in matches_response ] return pd . concat ( unfolded_lobbies ) . reset_index ( drop = True ) @staticmethod def match ( match_response : MatchLobby ) -> pd . DataFrame : \"\"\" Convert the content of a MatchLobby to a pandas DataFrame. The resulting DataFrame will have as many rows as there are players in the lobby, and all global attributes will be broadcasted to columns of the same length, making them duplicates. Args: match_response (MatchLobby): a MatchLobby object. Returns: A pandas DataFrame from the MatchLobby attributes, each row being global information from the MatchLobby as well as one of the players in the lobby. \"\"\" return _unfold_match_lobby_to_dataframe ( match_response ) @staticmethod def num_online ( num_online_response : NumOnlineResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().num_online to a pandas DataFrame. Args: num_online_response (NumOnlineResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the NumOnlineResponse, each row being an entry in the leaderboard. Top level attributes such as 'app_id' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. \"\"\" if not isinstance ( num_online_response , NumOnlineResponse ): logger . error ( \"Tried to use method with a parameter of type != NumOnlineResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'NumOnlineResponse'\" ) logger . debug ( \"Converting NumOnlineResponse to DataFrame\" ) dframe = pd . DataFrame ( num_online_response . dict ()) logger . trace ( \"Exporting 'player_stats' attribute contents to columns\" ) dframe [ \"time\" ] = dframe . player_stats . apply ( lambda x : x [ \"time\" ]) . apply ( pd . to_datetime ) dframe [ \"steam\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"steam\" ]) dframe [ \"looking\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"looking\" ]) dframe [ \"in_game\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"in_game\" ]) dframe [ \"multiplayer\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer\" ]) dframe [ \"multiplayer_1h\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer_1h\" ]) dframe [ \"multiplayer_24h\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer_24h\" ]) logger . trace ( \"Removing 'player_stats' column to avoid nested & duplicate data\" ) dframe = dframe . drop ( columns = [ \"player_stats\" ]) return dframe # ----- Helpers ----- # def _export_tuple_elements_to_column_values_format ( dataframe : pd . DataFrame ) -> pd . DataFrame : \"\"\" Take in a pandas DataFrame with simple int values as columns, and elements being a tuple of (attribute_name, value) and cast it to have the attribute_name as column names, and the values as values. The original columns will be dropped in the process. Args: dataframe (pd.DataFrame): your pandas DataFrame. Returns: The refactored pandas DataFrame. \"\"\" dframe = dataframe . copy ( deep = True ) logger . trace ( \"Exporting attributes to columns and removing duplicate data\" ) for _ , col_index in enumerate ( dframe . columns ): attribute = dframe [ col_index ][ 0 ][ 0 ] dframe [ attribute ] = dframe [ col_index ] . apply ( lambda x : x [ 1 ]) dframe = dframe . drop ( columns = [ col_index ]) return dframe def _unfold_match_lobby_to_dataframe ( match_lobby : MatchLobby ) -> pd . DataFrame : \"\"\" Convert the content of a MatchLobby to a pandas DataFrame. The resulting DataFrame will have as many rows as there are players in the lobby, and all global attributes will be broadcasted to columns of the same length, making them duplicates. Args: match_lobby (MatchLobby): a MatchLobby object. Returns: A pandas DataFrame from the MatchLobby attributes, each row being global information from the MatchLobby as well as one of the players in the lobby. \"\"\" if not isinstance ( match_lobby , MatchLobby ): logger . error ( \"Tried to use method with a parameter of type != MatchLobby\" ) raise TypeError ( \"Provided parameter should be an instance of 'MatchLobby'\" ) logger . trace ( \"Unfolding MatchLobby.players contents to DataFrame\" ) dframe = pd . DataFrame ( match_lobby . players ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) dframe = dframe . rename ( columns = { \"name\" : \"player\" }) logger . trace ( \"Broadcasting global MatchLobby attributes\" ) attributes_df = pd . DataFrame () for attribute , value in match_lobby . dict () . items (): if attribute != \"players\" : attributes_df [ attribute ] = [ value ] * len ( dframe ) dframe = attributes_df . join ( dframe , how = \"outer\" ) logger . trace ( \"Converting timestamps to datetime objects\" ) dframe [ \"opened\" ] = pd . to_datetime ( dframe [ \"opened\" ], unit = \"s\" ) dframe [ \"started\" ] = pd . to_datetime ( dframe [ \"started\" ], unit = \"s\" ) dframe [ \"finished\" ] = pd . to_datetime ( dframe [ \"finished\" ], unit = \"s\" ) return dframe","title":"Module aoe2netwrapper.converters"},{"location":"reference/aoe2netwrapper/converters/#classes","text":"","title":"Classes"},{"location":"reference/aoe2netwrapper/converters/#convert","text":"class Convert ( / , * args , ** kwargs ) View Source class Convert : \"\"\" This is a convenience class providing methods to convert the outputs from the AoE2NetAPI query methods into pandas DataFrame objects. Every method below is a staticmethod, so no object has to be instantiated. \"\"\" @staticmethod def strings ( strings_response : StringsResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().strings to a pandas DataFrame. Args: strings_response (StringsResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the StringsResponse, each column being the values for a 'string' used by the API, and the index being the ID numbers. Since this is the result of a join for many 'strings' that do not have the same amount of values, the resulting dataframe will contain NaNs wherever a given 'string' does not have a value for the given index ID. \"\"\" if not isinstance ( strings_response , StringsResponse ) : logger . error ( \"Tried to use method with a parameter of type != StringsResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'StringsResponse'\" ) logger . debug ( \"Converting StringsResponse to DataFrame\" ) dframe = pd . DataFrame ( strings_response ). transpose () dframe . columns = dframe . iloc [ 0 ] dframe = dframe . drop ( index =[ 0 ] ). reset_index ( drop = True ) dframe = dframe . drop ( columns =[ \"language\" ] ) logger . trace ( \"Exporting each string attribute to its own dataframe and joining\" ) result = pd . DataFrame () for col in dframe . columns : intermediate = pd . DataFrame () intermediate [ col ] = dframe [ col ][ 0 ] intermediate [ \"id\" ] = intermediate [ col ] . apply ( lambda x : x . id ) intermediate [ col ] = intermediate [ col ] . apply ( lambda x : x . string ) result = result . join ( intermediate . set_index ( \"id\" ), how = \"outer\" ) return result @staticmethod def leaderboard ( leaderboard_response : LeaderBoardResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Args: leaderboard_response (LeaderBoardResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the LeaderBoardResponse, each row being an entry in the leaderboard. Top level attributes such as 'start' or 'total' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. \"\"\" if not isinstance ( leaderboard_response , LeaderBoardResponse ) : logger . error ( \"Tried to use method with a parameter of type != LeaderBoardResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'LeaderBoardResponse'\" ) logger . debug ( \"Converting LeaderBoardResponse leaderboard to DataFrame\" ) dframe = pd . DataFrame ( leaderboard_response . leaderboard ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) logger . trace ( \"Inserting LeaderBoardResponse attributes as columns\" ) dframe [ \"leaderboard_id\" ] = leaderboard_response . leaderboard_id dframe [ \"start\" ] = leaderboard_response . start dframe [ \"count\" ] = leaderboard_response . count dframe [ \"total\" ] = leaderboard_response . total logger . trace ( \"Converting datetimes\" ) dframe [ \"last_match\" ] = pd . to_datetime ( dframe [ \"last_match\" ] , unit = \"s\" ) dframe [ \"last_match_time\" ] = pd . to_datetime ( dframe [ \"last_match_time\" ] , unit = \"s\" ) return dframe @staticmethod def lobbies ( lobbies_response : List [ MatchLobby ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().lobbies to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: lobbies_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements.. \"\"\" if not isinstance ( lobbies_response , list ) : # move list to List [ MatchLobby ] when supporting > 3.9 logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Lobbies response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe(match_lobby) for match_lobby in lobbies_response ] return pd . concat ( unfolded_lobbies ). reset_index ( drop = True ) @staticmethod def last_match ( last_match_response : LastMatchResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().last_match to a pandas DataFrame. There is not much use to this as the DataFrame will only have one row, but the method is provided nonetheless in case users want to concatenate several of these results in a DataFrame. Args: last_match_response (LastMatchResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of LastMatchResponse attributes. Beware: the 'players' column is directly the content of the 'LastMatchResponse.last_match.players' attribute and as such holds a list of LobbyMember objects. \"\"\" if not isinstance ( last_match_response , LastMatchResponse ) : logger . error ( \"Tried to use method with a parameter of type != LastMatchResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'LastMatchResponse'\" ) logger . debug ( \"Converting LastMatchResponse last_match to DataFrame\" ) dframe = pd . DataFrame ( last_match_response . last_match ). transpose () dframe . columns = dframe . iloc [ 0 ] dframe = dframe . drop ( 0 ). reset_index () logger . trace ( \"Inserting LastMatchResponse attributes as columns\" ) dframe [ \"profile_id\" ] = last_match_response . profile_id dframe [ \"steam_id\" ] = last_match_response . steam_id dframe [ \"name\" ] = last_match_response . name dframe [ \"country\" ] = last_match_response . country return dframe @staticmethod def match_history ( match_history_response : List [ MatchLobby ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: match_history_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements. \"\"\" # move list to List [ MatchLobby ] when supporting > 3.9 if not isinstance ( match_history_response , list ) : logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Match History response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe(match_lobby) for match_lobby in match_history_response ] return pd . concat ( unfolded_lobbies ). reset_index ( drop = True ) @staticmethod def rating_history ( rating_history_response : List [ RatingTimePoint ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Args: rating_history_response (List[RatingTimePoint]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of RatingTimePoint elements, each row being the information from one RatingTimePoint in the list. Timestamps are converted to datetime objects. \"\"\" # move list to List [ RatingTimePoint ] when supporting > 3.9 if not isinstance ( rating_history_response , list ) : logger . error ( \"Tried to use method with a parameter of type != List[RatingTimePoint]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[RatingTimePoint]'\" ) logger . debug ( \"Converting Rating History rsponse to DataFrame\" ) dframe = pd . DataFrame ( rating_history_response ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) logger . trace ( \"Converting timestamps to datetime objects\" ) dframe [ \"time\" ] = pd . to_datetime ( dframe [ \"timestamp\" ] , unit = \"s\" ) dframe = dframe . drop ( columns =[ \"timestamp\" ] ) return dframe @staticmethod def matches ( matches_response : List [ MatchLobby ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: matches_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements. \"\"\" if not isinstance ( matches_response , list ) : # move list to List [ MatchLobby ] when supporting > 3.9 logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Match History response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe(match_lobby) for match_lobby in matches_response ] return pd . concat ( unfolded_lobbies ). reset_index ( drop = True ) @staticmethod def match ( match_response : MatchLobby ) -> pd . DataFrame : \"\"\" Convert the content of a MatchLobby to a pandas DataFrame. The resulting DataFrame will have as many rows as there are players in the lobby, and all global attributes will be broadcasted to columns of the same length, making them duplicates. Args: match_response (MatchLobby): a MatchLobby object. Returns: A pandas DataFrame from the MatchLobby attributes, each row being global information from the MatchLobby as well as one of the players in the lobby. \"\"\" return _unfold_match_lobby_to_dataframe ( match_response ) @staticmethod def num_online ( num_online_response : NumOnlineResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().num_online to a pandas DataFrame. Args: num_online_response (NumOnlineResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the NumOnlineResponse, each row being an entry in the leaderboard. Top level attributes such as 'app_id' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. \"\"\" if not isinstance ( num_online_response , NumOnlineResponse ) : logger . error ( \"Tried to use method with a parameter of type != NumOnlineResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'NumOnlineResponse'\" ) logger . debug ( \"Converting NumOnlineResponse to DataFrame\" ) dframe = pd . DataFrame ( num_online_response . dict ()) logger . trace ( \"Exporting 'player_stats' attribute contents to columns\" ) dframe [ \"time\" ] = dframe . player_stats . apply ( lambda x : x [ \"time\" ] ). apply ( pd . to_datetime ) dframe [ \"steam\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"steam\" ] ) dframe [ \"looking\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"looking\" ] ) dframe [ \"in_game\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"in_game\" ] ) dframe [ \"multiplayer\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer\" ] ) dframe [ \"multiplayer_1h\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer_1h\" ] ) dframe [ \"multiplayer_24h\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer_24h\" ] ) logger . trace ( \"Removing 'player_stats' column to avoid nested & duplicate data\" ) dframe = dframe . drop ( columns =[ \"player_stats\" ] ) return dframe","title":"Convert"},{"location":"reference/aoe2netwrapper/converters/#static-methods","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/converters/#last_match","text":"def last_match ( last_match_response : aoe2netwrapper . models . last_match . LastMatchResponse ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().last_match to a pandas DataFrame. There is not much use to this as the DataFrame will only have one row, but the method is provided nonetheless in case users want to concatenate several of these results in a DataFrame. Parameters: Name Type Description Default last_match_response LastMatchResponse the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the list of LastMatchResponse attributes. Beware: the 'players' column is directly the content of the 'LastMatchResponse.last_match.players' attribute and as such holds a list of LobbyMember objects. View Source @staticmethod def last_match ( last_match_response : LastMatchResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().last_match to a pandas DataFrame. There is not much use to this as the DataFrame will only have one row, but the method is provided nonetheless in case users want to concatenate several of these results in a DataFrame. Args: last_match_response (LastMatchResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of LastMatchResponse attributes. Beware: the 'players' column is directly the content of the 'LastMatchResponse.last_match.players' attribute and as such holds a list of LobbyMember objects. \"\"\" if not isinstance ( last_match_response , LastMatchResponse ) : logger . error ( \"Tried to use method with a parameter of type != LastMatchResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'LastMatchResponse'\" ) logger . debug ( \"Converting LastMatchResponse last_match to DataFrame\" ) dframe = pd . DataFrame ( last_match_response . last_match ). transpose () dframe . columns = dframe . iloc [ 0 ] dframe = dframe . drop ( 0 ). reset_index () logger . trace ( \"Inserting LastMatchResponse attributes as columns\" ) dframe [ \"profile_id\" ] = last_match_response . profile_id dframe [ \"steam_id\" ] = last_match_response . steam_id dframe [ \"name\" ] = last_match_response . name dframe [ \"country\" ] = last_match_response . country return dframe","title":"last_match"},{"location":"reference/aoe2netwrapper/converters/#leaderboard","text":"def leaderboard ( leaderboard_response : aoe2netwrapper . models . leaderboard . LeaderBoardResponse ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Parameters: Name Type Description Default leaderboard_response LeaderBoardResponse the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the LeaderBoardResponse, each row being an entry in the leaderboard. Top level attributes such as 'start' or 'total' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. View Source @ staticmethod def leaderboard ( leaderboard_response : LeaderBoardResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Args: leaderboard_response (LeaderBoardResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the LeaderBoardResponse, each row being an entry in the leaderboard. Top level attributes such as 'start' or 'total' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. \"\"\" if not isinstance ( leaderboard_response , LeaderBoardResponse ): logger . error ( \"Tried to use method with a parameter of type != LeaderBoardResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'LeaderBoardResponse'\" ) logger . debug ( \"Converting LeaderBoardResponse leaderboard to DataFrame\" ) dframe = pd . DataFrame ( leaderboard_response . leaderboard ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) logger . trace ( \"Inserting LeaderBoardResponse attributes as columns\" ) dframe [ \"leaderboard_id\" ] = leaderboard_response . leaderboard_id dframe [ \"start\" ] = leaderboard_response . start dframe [ \"count\" ] = leaderboard_response . count dframe [ \"total\" ] = leaderboard_response . total logger . trace ( \"Converting datetimes\" ) dframe [ \"last_match\" ] = pd . to_datetime ( dframe [ \"last_match\" ], unit = \"s\" ) dframe [ \"last_match_time\" ] = pd . to_datetime ( dframe [ \"last_match_time\" ], unit = \"s\" ) return dframe","title":"leaderboard"},{"location":"reference/aoe2netwrapper/converters/#lobbies","text":"def lobbies ( lobbies_response : List [ aoe2netwrapper . models . lobbies . MatchLobby ] ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().lobbies to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Parameters: Name Type Description Default lobbies_response List[MatchLobby] the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the list of MatchLobby elements.. View Source @staticmethod def lobbies ( lobbies_response : List [ MatchLobby ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().lobbies to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: lobbies_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements.. \"\"\" if not isinstance ( lobbies_response , list ) : # move list to List [ MatchLobby ] when supporting > 3.9 logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Lobbies response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe(match_lobby) for match_lobby in lobbies_response ] return pd . concat ( unfolded_lobbies ). reset_index ( drop = True )","title":"lobbies"},{"location":"reference/aoe2netwrapper/converters/#match","text":"def match ( match_response : aoe2netwrapper . models . lobbies . MatchLobby ) -> pandas . core . frame . DataFrame Convert the content of a MatchLobby to a pandas DataFrame. The resulting DataFrame will have as many rows as there are players in the lobby, and all global attributes will be broadcasted to columns of the same length, making them duplicates. Parameters: Name Type Description Default match_response MatchLobby a MatchLobby object. None Returns: Type Description None A pandas DataFrame from the MatchLobby attributes, each row being global information from the MatchLobby as well as one of the players in the lobby. View Source @staticmethod def match ( match_response : MatchLobby ) -> pd . DataFrame : \"\"\" Convert the content of a MatchLobby to a pandas DataFrame. The resulting DataFrame will have as many rows as there are players in the lobby, and all global attributes will be broadcasted to columns of the same length, making them duplicates. Args: match_response (MatchLobby): a MatchLobby object. Returns: A pandas DataFrame from the MatchLobby attributes, each row being global information from the MatchLobby as well as one of the players in the lobby. \"\"\" return _unfold_match_lobby_to_dataframe ( match_response )","title":"match"},{"location":"reference/aoe2netwrapper/converters/#match_history","text":"def match_history ( match_history_response : List [ aoe2netwrapper . models . lobbies . MatchLobby ] ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Parameters: Name Type Description Default match_history_response List[MatchLobby] the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the list of MatchLobby elements. View Source @staticmethod def match_history ( match_history_response : List [ MatchLobby ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: match_history_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements. \"\"\" # move list to List [ MatchLobby ] when supporting > 3.9 if not isinstance ( match_history_response , list ) : logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Match History response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe(match_lobby) for match_lobby in match_history_response ] return pd . concat ( unfolded_lobbies ). reset_index ( drop = True )","title":"match_history"},{"location":"reference/aoe2netwrapper/converters/#matches","text":"def matches ( matches_response : List [ aoe2netwrapper . models . lobbies . MatchLobby ] ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Parameters: Name Type Description Default matches_response List[MatchLobby] the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the list of MatchLobby elements. View Source @staticmethod def matches ( matches_response : List [ MatchLobby ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().match_history to a pandas DataFrame. The resulting DataFrame will contain several rows for each lobby, namely as many as there are players in said lobby. All global attributes of each lobby are broadcasted to arrays, making them duplicates. To isolate a specific lobby, either call the AoE2NetAPI().match method with the lobby's UUID or make use of the groupby functionality of pandas DataFrames. Args: matches_response (List[MatchLobby]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of MatchLobby elements. \"\"\" if not isinstance ( matches_response , list ) : # move list to List [ MatchLobby ] when supporting > 3.9 logger . error ( \"Tried to use method with a parameter of type != List[MatchLobby]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[MatchLobby]'\" ) logger . debug ( \"Converting Match History response to DataFrame\" ) unfolded_lobbies = [ _unfold_match_lobby_to_dataframe(match_lobby) for match_lobby in matches_response ] return pd . concat ( unfolded_lobbies ). reset_index ( drop = True )","title":"matches"},{"location":"reference/aoe2netwrapper/converters/#num_online","text":"def num_online ( num_online_response : aoe2netwrapper . models . num_online . NumOnlineResponse ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().num_online to a pandas DataFrame. Parameters: Name Type Description Default num_online_response NumOnlineResponse the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the NumOnlineResponse, each row being an entry in the leaderboard. Top level attributes such as 'app_id' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. View Source @staticmethod def num_online ( num_online_response : NumOnlineResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().num_online to a pandas DataFrame. Args: num_online_response (NumOnlineResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the NumOnlineResponse, each row being an entry in the leaderboard. Top level attributes such as 'app_id' are broadcast to an entire array the size of the dataframe, and timestamps are converted to datetime objects. \"\"\" if not isinstance ( num_online_response , NumOnlineResponse ) : logger . error ( \"Tried to use method with a parameter of type != NumOnlineResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'NumOnlineResponse'\" ) logger . debug ( \"Converting NumOnlineResponse to DataFrame\" ) dframe = pd . DataFrame ( num_online_response . dict ()) logger . trace ( \"Exporting 'player_stats' attribute contents to columns\" ) dframe [ \"time\" ] = dframe . player_stats . apply ( lambda x : x [ \"time\" ] ). apply ( pd . to_datetime ) dframe [ \"steam\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"steam\" ] ) dframe [ \"looking\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"looking\" ] ) dframe [ \"in_game\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"in_game\" ] ) dframe [ \"multiplayer\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer\" ] ) dframe [ \"multiplayer_1h\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer_1h\" ] ) dframe [ \"multiplayer_24h\" ] = dframe . player_stats . apply ( lambda x : x [ \"num_players\" ][ \"multiplayer_24h\" ] ) logger . trace ( \"Removing 'player_stats' column to avoid nested & duplicate data\" ) dframe = dframe . drop ( columns =[ \"player_stats\" ] ) return dframe","title":"num_online"},{"location":"reference/aoe2netwrapper/converters/#rating_history","text":"def rating_history ( rating_history_response : List [ aoe2netwrapper . models . rating_history . RatingTimePoint ] ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Parameters: Name Type Description Default rating_history_response List[RatingTimePoint] the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the list of RatingTimePoint elements, each row being the information from one RatingTimePoint in the list. Timestamps are converted to datetime objects. View Source @staticmethod def rating_history ( rating_history_response : List [ RatingTimePoint ] ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().leaderboard to a pandas DataFrame. Args: rating_history_response (List[RatingTimePoint]): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the list of RatingTimePoint elements, each row being the information from one RatingTimePoint in the list. Timestamps are converted to datetime objects. \"\"\" # move list to List [ RatingTimePoint ] when supporting > 3.9 if not isinstance ( rating_history_response , list ) : logger . error ( \"Tried to use method with a parameter of type != List[RatingTimePoint]\" ) raise TypeError ( \"Provided parameter should be an instance of 'List[RatingTimePoint]'\" ) logger . debug ( \"Converting Rating History rsponse to DataFrame\" ) dframe = pd . DataFrame ( rating_history_response ) dframe = _export_tuple_elements_to_column_values_format ( dframe ) logger . trace ( \"Converting timestamps to datetime objects\" ) dframe [ \"time\" ] = pd . to_datetime ( dframe [ \"timestamp\" ] , unit = \"s\" ) dframe = dframe . drop ( columns =[ \"timestamp\" ] ) return dframe","title":"rating_history"},{"location":"reference/aoe2netwrapper/converters/#strings","text":"def strings ( strings_response : aoe2netwrapper . models . strings . StringsResponse ) -> pandas . core . frame . DataFrame Convert the result given by a call to AoE2NetAPI().strings to a pandas DataFrame. Parameters: Name Type Description Default strings_response StringsResponse the response directly returned by your AoE2NetAPI client. None Returns: Type Description None A pandas DataFrame from the StringsResponse, each column being the values for a 'string' used by the API, and the index being the ID numbers. Since this is the result of a join for many 'strings' that do not have the same amount of values, the resulting dataframe will contain NaNs wherever a given 'string' does not have a value for the given index ID. View Source @staticmethod def strings ( strings_response : StringsResponse ) -> pd . DataFrame : \"\"\" Convert the result given by a call to AoE2NetAPI().strings to a pandas DataFrame. Args: strings_response (StringsResponse): the response directly returned by your AoE2NetAPI client. Returns: A pandas DataFrame from the StringsResponse, each column being the values for a 'string' used by the API, and the index being the ID numbers. Since this is the result of a join for many 'strings' that do not have the same amount of values, the resulting dataframe will contain NaNs wherever a given 'string' does not have a value for the given index ID. \"\"\" if not isinstance ( strings_response , StringsResponse ) : logger . error ( \"Tried to use method with a parameter of type != StringsResponse\" ) raise TypeError ( \"Provided parameter should be an instance of 'StringsResponse'\" ) logger . debug ( \"Converting StringsResponse to DataFrame\" ) dframe = pd . DataFrame ( strings_response ). transpose () dframe . columns = dframe . iloc [ 0 ] dframe = dframe . drop ( index =[ 0 ] ). reset_index ( drop = True ) dframe = dframe . drop ( columns =[ \"language\" ] ) logger . trace ( \"Exporting each string attribute to its own dataframe and joining\" ) result = pd . DataFrame () for col in dframe . columns : intermediate = pd . DataFrame () intermediate [ col ] = dframe [ col ][ 0 ] intermediate [ \"id\" ] = intermediate [ col ] . apply ( lambda x : x . id ) intermediate [ col ] = intermediate [ col ] . apply ( lambda x : x . string ) result = result . join ( intermediate . set_index ( \"id\" ), how = \"outer\" ) return result","title":"strings"},{"location":"reference/aoe2netwrapper/exceptions/","text":"Module aoe2netwrapper.exceptions aoe2netwrapper.exceptions This module contains the set of exceptions used in the package. View Source \"\"\" aoe2netwrapper.exceptions ------------------------- This module contains the set of exceptions used in the package. \"\"\" class Aoe2NetException ( Exception ): \"\"\"Default exception for AoE2.net API interaction.\"\"\" class NightBotException ( Exception ): \"\"\"Default exception for AoE2.net Nightbot API interaction.\"\"\" Classes Aoe2NetException class Aoe2NetException ( / , * args , ** kwargs ) View Source class Aoe2NetException ( Exception ): \"\"\"Default exception for AoE2.net API interaction.\"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. NightBotException class NightBotException ( / , * args , ** kwargs ) View Source class NightBotException ( Exception ): \"\"\"Default exception for AoE2.net Nightbot API interaction.\"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/aoe2netwrapper/exceptions/#module-aoe2netwrapperexceptions","text":"aoe2netwrapper.exceptions This module contains the set of exceptions used in the package. View Source \"\"\" aoe2netwrapper.exceptions ------------------------- This module contains the set of exceptions used in the package. \"\"\" class Aoe2NetException ( Exception ): \"\"\"Default exception for AoE2.net API interaction.\"\"\" class NightBotException ( Exception ): \"\"\"Default exception for AoE2.net Nightbot API interaction.\"\"\"","title":"Module aoe2netwrapper.exceptions"},{"location":"reference/aoe2netwrapper/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/aoe2netwrapper/exceptions/#aoe2netexception","text":"class Aoe2NetException ( / , * args , ** kwargs ) View Source class Aoe2NetException ( Exception ): \"\"\"Default exception for AoE2.net API interaction.\"\"\"","title":"Aoe2NetException"},{"location":"reference/aoe2netwrapper/exceptions/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/exceptions/#class-variables","text":"args","title":"Class variables"},{"location":"reference/aoe2netwrapper/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/aoe2netwrapper/exceptions/#nightbotexception","text":"class NightBotException ( / , * args , ** kwargs ) View Source class NightBotException ( Exception ): \"\"\"Default exception for AoE2.net Nightbot API interaction.\"\"\"","title":"NightBotException"},{"location":"reference/aoe2netwrapper/exceptions/#ancestors-in-mro_1","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/exceptions/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/aoe2netwrapper/exceptions/#methods_1","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/exceptions/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/aoe2netwrapper/nightbot/","text":"Module aoe2netwrapper.nightbot aoe2netwrapper.nightbot This module implements a high-level client to query the API at https://aoe2.net/#nightbot . View Source \"\"\" aoe2netwrapper.nightbot ----------------------- This module implements a high-level client to query the API at https://aoe2.net/#nightbot. \"\"\" from typing import Any , Dict , Tuple , Union import requests from loguru import logger from aoe2netwrapper.exceptions import NightBotException class AoE2NightbotAPI : \"\"\" The 'AoE2NightbotAPI' class is a client that encompasses the https://aoe2.net/#nightbot API endpoints, which only return their requested data as plain text. \"\"\" NIGHTBOT_BASE_URL : str = \"https://aoe2.net/api/nightbot\" RANK_DETAILS_ENDPOINT = NIGHTBOT_BASE_URL + \"/rank\" RECENT_OPPONENT_ENDPOINT = NIGHTBOT_BASE_URL + \"/opponent\" CURRENT_MATCH_ENDPOINT = NIGHTBOT_BASE_URL + \"/match\" CURRENT_CIVS_ENDPOINT = NIGHTBOT_BASE_URL + \"/civs\" CURRENT_MAP_ENDPOINT = NIGHTBOT_BASE_URL + \"/map\" def __init__ ( self , timeout : Union [ float , Tuple [ float , float ]] = 5 ): \"\"\"Creating a Session for connection pooling since we're always querying the same host.\"\"\" self . session = requests . Session () self . timeout = timeout def __repr__ ( self ) -> str : return f \"Client for <{self.NIGHTBOT_BASE_URL}>\" def rank ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , flag : str = \"true\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\"\" Request rank details about a player. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. flag (str): boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for rank details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . RANK_DETAILS_ENDPOINT , params = query_params , timeout = self . timeout , ) def opponent ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , flag : str = \"true\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\"\" Request rank details about a player's most recent opponent (1v1 only). Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. flag (str): boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for opponent details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . RECENT_OPPONENT_ENDPOINT , params = query_params , timeout = self . timeout , ) def match ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , color : str = \"true\" , flag : str = \"true\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\"\" Request details about the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. color (str): boolean to show player colors. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. flag (str): boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the players in the match. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for match details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"color\" : color , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) def civs ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\"\" Request civilisations from the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for civilisations details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_CIVS_ENDPOINT , params = query_params , timeout = self . timeout , ) def map ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\"\" Request civilisations from the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for civilisations details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_MAP_ENDPOINT , params = query_params , timeout = self . timeout , ) # ----- Helpers ----- # def _get_request_text_response_decoded ( session : requests . Session , url : str , params : Dict [ str , Any ] = None , timeout : Union [ float , Tuple [ float , float ]] = None , ) -> str : \"\"\" Helper function to handle a GET request to an endpoint and return the response JSON content as a dictionary. Args: session (requests.Session): Session object to use, for connection pooling and performance. url (str): API endpoint to send the request to. params (dict): A dictionary of parameters for the GET request. Raises: Aoe2NetException: if the status code returned is not 200. Returns: The request's JSON response as a dictionary. \"\"\" default_headers = { \"content-type\" : \"application/json;charset=UTF-8\" } logger . debug ( f \"Sending GET request at '{url}'\" ) logger . trace ( f \"Parameters are: {str(params)}\" ) response = session . get ( url , params = params , headers = default_headers , timeout = timeout ) if response . status_code != 200 : logger . error ( f \"GET request at '{response.url}' returned a {response.status_code} status code\" ) raise NightBotException ( f \"Expected status code 200 - got {response.status_code} instead.\" ) return response . text Classes AoE2NightbotAPI class AoE2NightbotAPI ( timeout : Union [ float , Tuple [ float , float ]] = 5 ) View Source class AoE2NightbotAPI: \"\"\" The 'AoE2NightbotAPI' class is a client that encompasses the https://aoe2.net/#nightbot API endpoints, which only return their requested data as plain text. \"\"\" NIGHTBOT_BASE_URL: str = \"https://aoe2.net/api/nightbot\" RANK_DETAILS_ENDPOINT = NIGHTBOT_BASE_URL + \"/rank\" RECENT_OPPONENT_ENDPOINT = NIGHTBOT_BASE_URL + \"/opponent\" CURRENT_MATCH_ENDPOINT = NIGHTBOT_BASE_URL + \"/match\" CURRENT_CIVS_ENDPOINT = NIGHTBOT_BASE_URL + \"/civs\" CURRENT_MAP_ENDPOINT = NIGHTBOT_BASE_URL + \"/map\" def __init__ ( self , timeout: Union [ float , Tuple [ float , float ]] = 5 ): \"\"\"Creating a Session for connection pooling since we're always querying the same host.\"\"\" self . session = requests . Session () self . timeout = timeout def __repr__ ( self ) -> str: return f \"Client for <{self.NIGHTBOT_BASE_URL}>\" def rank ( self , game: str = \"aoe2de\" , leaderboard_id: int = 3 , language: str = \"en\" , flag: str = \"true\" , search: str = None , steam_id: int = None , profile_id: int = None , ) -> str: \"\"\" Request rank details about a player. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. flag (str): boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for rank details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . RANK_DETAILS_ENDPOINT , params = query_params , timeout = self . timeout , ) def opponent ( self , game: str = \"aoe2de\" , leaderboard_id: int = 3 , language: str = \"en\" , flag: str = \"true\" , search: str = None , steam_id: int = None , profile_id: int = None , ) -> str: \"\"\" Request rank details about a player's most recent opponent (1v1 only). Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. flag (str): boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for opponent details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . RECENT_OPPONENT_ENDPOINT , params = query_params , timeout = self . timeout , ) def match ( self , game: str = \"aoe2de\" , leaderboard_id: int = 3 , language: str = \"en\" , color: str = \"true\" , flag: str = \"true\" , search: str = None , steam_id: int = None , profile_id: int = None , ) -> str: \"\"\" Request details about the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. color (str): boolean to show player colors. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. flag (str): boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the players in the match. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for match details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"color\" : color , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) def civs ( self , game: str = \"aoe2de\" , leaderboard_id: int = 3 , language: str = \"en\" , search: str = None , steam_id: int = None , profile_id: int = None , ) -> str: \"\"\" Request civilisations from the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for civilisations details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_CIVS_ENDPOINT , params = query_params , timeout = self . timeout , ) def map ( self , game: str = \"aoe2de\" , leaderboard_id: int = 3 , language: str = \"en\" , search: str = None , steam_id: int = None , profile_id: int = None , ) -> str: \"\"\" Request civilisations from the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for civilisations details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_MAP_ENDPOINT , params = query_params , timeout = self . timeout , ) Class variables CURRENT_CIVS_ENDPOINT CURRENT_MAP_ENDPOINT CURRENT_MATCH_ENDPOINT NIGHTBOT_BASE_URL RANK_DETAILS_ENDPOINT RECENT_OPPONENT_ENDPOINT Methods civs def civs ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , language : str = 'en' , search : str = None , steam_id : int = None , profile_id : int = None ) -> str Request civilisations from the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None language str language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. None search str To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. None steam_id int To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). None profile_id int To perform the search for a specific player, from their profile ID (ex: 459658). None Returns: Type Description None The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. Raises: Type Description NightBotException if the not one of 'search', 'steam_id' or 'profile_id' are provided. View Source def civs ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\" \" Request civilisations from the current or last match . Either 'search' , 'steam_id' or 'profile_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). leaderboard_id ( int ): Leaderboard to extract the data for ( Unranked = 0 , 1 v1 Deathmatch = 1 , Team Deathmatch = 2 , 1 v1 Random Map = 3 , Team Random Map = 4 ). Defaults to 3 . language ( str ): language for the returned response ( 'en' , 'de' , 'el' , 'es' , 'es-MX' , 'fr' , 'hi' , 'it' , 'ja' , 'ko' , 'ms' , 'nl' , 'pt' , 'ru' , 'tr' , 'vi' , 'zh' , 'zh-TW' ). Defaults to 'en' . search ( str ): To perform the search for a specific player , from their name . Will return the highest rated player that matches the search . steam_id ( int ): To perform the search for a specific player , from their steamID64 ( ex : 76561199003184910 ). profile_id ( int ): To perform the search for a specific player , from their profile ID ( ex : 459658 ). Raises : NightBotException : if the not one of 'search' , 'steam_id' or 'profile_id' are provided . Returns : The text content of the response , as a decoded unicode string , with a quick sentence of information about the player ' s last opponent . \"\" \" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for civilisations details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_CIVS_ENDPOINT , params = query_params , timeout = self . timeout , ) map def map ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , language : str = 'en' , search : str = None , steam_id : int = None , profile_id : int = None ) -> str Request civilisations from the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None language str language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. None search str To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. None steam_id int To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). None profile_id int To perform the search for a specific player, from their profile ID (ex: 459658). None Returns: Type Description None The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. Raises: Type Description NightBotException if the not one of 'search', 'steam_id' or 'profile_id' are provided. View Source def map ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\" \" Request civilisations from the current or last match . Either 'search' , 'steam_id' or 'profile_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). leaderboard_id ( int ): Leaderboard to extract the data for ( Unranked = 0 , 1 v1 Deathmatch = 1 , Team Deathmatch = 2 , 1 v1 Random Map = 3 , Team Random Map = 4 ). Defaults to 3 . language ( str ): language for the returned response ( 'en' , 'de' , 'el' , 'es' , 'es-MX' , 'fr' , 'hi' , 'it' , 'ja' , 'ko' , 'ms' , 'nl' , 'pt' , 'ru' , 'tr' , 'vi' , 'zh' , 'zh-TW' ). Defaults to 'en' . search ( str ): To perform the search for a specific player , from their name . Will return the highest rated player that matches the search . steam_id ( int ): To perform the search for a specific player , from their steamID64 ( ex : 76561199003184910 ). profile_id ( int ): To perform the search for a specific player , from their profile ID ( ex : 459658 ). Raises : NightBotException : if the not one of 'search' , 'steam_id' or 'profile_id' are provided . Returns : The text content of the response , as a decoded unicode string , with a quick sentence of information about the player ' s last opponent . \"\" \" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for civilisations details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_MAP_ENDPOINT , params = query_params , timeout = self . timeout , ) match def match ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , language : str = 'en' , color : str = 'true' , flag : str = 'true' , search : str = None , steam_id : int = None , profile_id : int = None ) -> str Request details about the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None language str language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. None color str boolean to show player colors. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. 'true' flag str boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. 'true' search str To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. None steam_id int To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). None profile_id int To perform the search for a specific player, from their profile ID (ex: 459658). None Returns: Type Description None The text content of the response, as a decoded unicode string, with a quick sentence of information about the players in the match. Raises: Type Description NightBotException if the not one of 'search', 'steam_id' or 'profile_id' are provided. View Source def match ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , color : str = \"true\" , flag : str = \"true\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\" \" Request details about the current or last match . Either 'search' , 'steam_id' or 'profile_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). leaderboard_id ( int ): Leaderboard to extract the data for ( Unranked = 0 , 1 v1 Deathmatch = 1 , Team Deathmatch = 2 , 1 v1 Random Map = 3 , Team Random Map = 4 ). Defaults to 3 . language ( str ): language for the returned response ( 'en' , 'de' , 'el' , 'es' , 'es-MX' , 'fr' , 'hi' , 'it' , 'ja' , 'ko' , 'ms' , 'nl' , 'pt' , 'ru' , 'tr' , 'vi' , 'zh' , 'zh-TW' ). Defaults to 'en' . color ( str ): boolean to show player colors . Defaults to 'true' . Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that . flag ( str ): boolean to show the player flag . Defaults to 'true' . Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that . search ( str ): To perform the search for a specific player , from their name . Will return the highest rated player that matches the search . steam_id ( int ): To perform the search for a specific player , from their steamID64 ( ex : 76561199003184910 ). profile_id ( int ): To perform the search for a specific player , from their profile ID ( ex : 459658 ). Raises : NightBotException : if the not one of 'search' , 'steam_id' or 'profile_id' are provided . Returns : The text content of the response , as a decoded unicode string , with a quick sentence of information about the players in the match . \"\" \" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for match details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"color\" : color , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) opponent def opponent ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , language : str = 'en' , flag : str = 'true' , search : str = None , steam_id : int = None , profile_id : int = None ) -> str Request rank details about a player's most recent opponent (1v1 only). Either 'search', 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None language str language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. None flag str boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. 'true' search str To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. None steam_id int To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). None profile_id int To perform the search for a specific player, from their profile ID (ex: 459658). None Returns: Type Description None The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. Raises: Type Description NightBotException if the not one of 'search', 'steam_id' or 'profile_id' are provided. View Source def opponent ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , flag : str = \"true\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\" \" Request rank details about a player 's most recent opponent (1v1 only). Either ' search ' , 'steam_id' or 'profile_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). leaderboard_id ( int ): Leaderboard to extract the data for ( Unranked = 0 , 1 v1 Deathmatch = 1 , Team Deathmatch = 2 , 1 v1 Random Map = 3 , Team Random Map = 4 ). Defaults to 3 . language ( str ): language for the returned response ( 'en' , 'de' , 'el' , 'es' , 'es-MX' , 'fr' , 'hi' , 'it' , 'ja' , 'ko' , 'ms' , 'nl' , 'pt' , 'ru' , 'tr' , 'vi' , 'zh' , 'zh-TW' ). Defaults to 'en' . flag ( str ): boolean to show the player flag . Defaults to 'true' . Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that . search ( str ): To perform the search for a specific player , from their name . Will return the highest rated player that matches the search . steam_id ( int ): To perform the search for a specific player , from their steamID64 ( ex : 76561199003184910 ). profile_id ( int ): To perform the search for a specific player , from their profile ID ( ex : 459658 ). Raises : NightBotException : if the not one of 'search' , 'steam_id' or 'profile_id' are provided . Returns : The text content of the response , as a decoded unicode string , with a quick sentence of information about the player ' s last opponent . \"\" \" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for opponent details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . RECENT_OPPONENT_ENDPOINT , params = query_params , timeout = self . timeout , ) rank def rank ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , language : str = 'en' , flag : str = 'true' , search : str = None , steam_id : int = None , profile_id : int = None ) -> str Request rank details about a player. Either 'search', 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None language str language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. None flag str boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. 'true' search str To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. None steam_id int To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). None profile_id int To perform the search for a specific player, from their profile ID (ex: 459658). None Returns: Type Description None The text content of the response, as a decoded unicode string, with a quick sentence of information about the player. Raises: Type Description NightBotException if the not one of 'search', 'steam_id' or 'profile_id' are provided. View Source def rank ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , flag : str = \"true\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\" \" Request rank details about a player . Either 'search' , 'steam_id' or 'profile_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). leaderboard_id ( int ): Leaderboard to extract the data for ( Unranked = 0 , 1 v1 Deathmatch = 1 , Team Deathmatch = 2 , 1 v1 Random Map = 3 , Team Random Map = 4 ). Defaults to 3 . language ( str ): language for the returned response ( 'en' , 'de' , 'el' , 'es' , 'es-MX' , 'fr' , 'hi' , 'it' , 'ja' , 'ko' , 'ms' , 'nl' , 'pt' , 'ru' , 'tr' , 'vi' , 'zh' , 'zh-TW' ). Defaults to 'en' . flag ( str ): boolean to show the player flag . Defaults to 'true' . Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that . search ( str ): To perform the search for a specific player , from their name . Will return the highest rated player that matches the search . steam_id ( int ): To perform the search for a specific player , from their steamID64 ( ex : 76561199003184910 ). profile_id ( int ): To perform the search for a specific player , from their profile ID ( ex : 459658 ). Raises : NightBotException : if the not one of 'search' , 'steam_id' or 'profile_id' are provided . Returns : The text content of the response , as a decoded unicode string , with a quick sentence of information about the player . \"\" \" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for rank details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . RANK_DETAILS_ENDPOINT , params = query_params , timeout = self . timeout , )","title":"Nightbot"},{"location":"reference/aoe2netwrapper/nightbot/#module-aoe2netwrappernightbot","text":"aoe2netwrapper.nightbot This module implements a high-level client to query the API at https://aoe2.net/#nightbot . View Source \"\"\" aoe2netwrapper.nightbot ----------------------- This module implements a high-level client to query the API at https://aoe2.net/#nightbot. \"\"\" from typing import Any , Dict , Tuple , Union import requests from loguru import logger from aoe2netwrapper.exceptions import NightBotException class AoE2NightbotAPI : \"\"\" The 'AoE2NightbotAPI' class is a client that encompasses the https://aoe2.net/#nightbot API endpoints, which only return their requested data as plain text. \"\"\" NIGHTBOT_BASE_URL : str = \"https://aoe2.net/api/nightbot\" RANK_DETAILS_ENDPOINT = NIGHTBOT_BASE_URL + \"/rank\" RECENT_OPPONENT_ENDPOINT = NIGHTBOT_BASE_URL + \"/opponent\" CURRENT_MATCH_ENDPOINT = NIGHTBOT_BASE_URL + \"/match\" CURRENT_CIVS_ENDPOINT = NIGHTBOT_BASE_URL + \"/civs\" CURRENT_MAP_ENDPOINT = NIGHTBOT_BASE_URL + \"/map\" def __init__ ( self , timeout : Union [ float , Tuple [ float , float ]] = 5 ): \"\"\"Creating a Session for connection pooling since we're always querying the same host.\"\"\" self . session = requests . Session () self . timeout = timeout def __repr__ ( self ) -> str : return f \"Client for <{self.NIGHTBOT_BASE_URL}>\" def rank ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , flag : str = \"true\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\"\" Request rank details about a player. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. flag (str): boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for rank details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . RANK_DETAILS_ENDPOINT , params = query_params , timeout = self . timeout , ) def opponent ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , flag : str = \"true\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\"\" Request rank details about a player's most recent opponent (1v1 only). Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. flag (str): boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for opponent details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . RECENT_OPPONENT_ENDPOINT , params = query_params , timeout = self . timeout , ) def match ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , color : str = \"true\" , flag : str = \"true\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\"\" Request details about the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. color (str): boolean to show player colors. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. flag (str): boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the players in the match. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for match details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"color\" : color , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) def civs ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\"\" Request civilisations from the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for civilisations details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_CIVS_ENDPOINT , params = query_params , timeout = self . timeout , ) def map ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\"\" Request civilisations from the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for civilisations details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_MAP_ENDPOINT , params = query_params , timeout = self . timeout , ) # ----- Helpers ----- # def _get_request_text_response_decoded ( session : requests . Session , url : str , params : Dict [ str , Any ] = None , timeout : Union [ float , Tuple [ float , float ]] = None , ) -> str : \"\"\" Helper function to handle a GET request to an endpoint and return the response JSON content as a dictionary. Args: session (requests.Session): Session object to use, for connection pooling and performance. url (str): API endpoint to send the request to. params (dict): A dictionary of parameters for the GET request. Raises: Aoe2NetException: if the status code returned is not 200. Returns: The request's JSON response as a dictionary. \"\"\" default_headers = { \"content-type\" : \"application/json;charset=UTF-8\" } logger . debug ( f \"Sending GET request at '{url}'\" ) logger . trace ( f \"Parameters are: {str(params)}\" ) response = session . get ( url , params = params , headers = default_headers , timeout = timeout ) if response . status_code != 200 : logger . error ( f \"GET request at '{response.url}' returned a {response.status_code} status code\" ) raise NightBotException ( f \"Expected status code 200 - got {response.status_code} instead.\" ) return response . text","title":"Module aoe2netwrapper.nightbot"},{"location":"reference/aoe2netwrapper/nightbot/#classes","text":"","title":"Classes"},{"location":"reference/aoe2netwrapper/nightbot/#aoe2nightbotapi","text":"class AoE2NightbotAPI ( timeout : Union [ float , Tuple [ float , float ]] = 5 ) View Source class AoE2NightbotAPI: \"\"\" The 'AoE2NightbotAPI' class is a client that encompasses the https://aoe2.net/#nightbot API endpoints, which only return their requested data as plain text. \"\"\" NIGHTBOT_BASE_URL: str = \"https://aoe2.net/api/nightbot\" RANK_DETAILS_ENDPOINT = NIGHTBOT_BASE_URL + \"/rank\" RECENT_OPPONENT_ENDPOINT = NIGHTBOT_BASE_URL + \"/opponent\" CURRENT_MATCH_ENDPOINT = NIGHTBOT_BASE_URL + \"/match\" CURRENT_CIVS_ENDPOINT = NIGHTBOT_BASE_URL + \"/civs\" CURRENT_MAP_ENDPOINT = NIGHTBOT_BASE_URL + \"/map\" def __init__ ( self , timeout: Union [ float , Tuple [ float , float ]] = 5 ): \"\"\"Creating a Session for connection pooling since we're always querying the same host.\"\"\" self . session = requests . Session () self . timeout = timeout def __repr__ ( self ) -> str: return f \"Client for <{self.NIGHTBOT_BASE_URL}>\" def rank ( self , game: str = \"aoe2de\" , leaderboard_id: int = 3 , language: str = \"en\" , flag: str = \"true\" , search: str = None , steam_id: int = None , profile_id: int = None , ) -> str: \"\"\" Request rank details about a player. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. flag (str): boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for rank details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . RANK_DETAILS_ENDPOINT , params = query_params , timeout = self . timeout , ) def opponent ( self , game: str = \"aoe2de\" , leaderboard_id: int = 3 , language: str = \"en\" , flag: str = \"true\" , search: str = None , steam_id: int = None , profile_id: int = None , ) -> str: \"\"\" Request rank details about a player's most recent opponent (1v1 only). Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. flag (str): boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for opponent details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . RECENT_OPPONENT_ENDPOINT , params = query_params , timeout = self . timeout , ) def match ( self , game: str = \"aoe2de\" , leaderboard_id: int = 3 , language: str = \"en\" , color: str = \"true\" , flag: str = \"true\" , search: str = None , steam_id: int = None , profile_id: int = None , ) -> str: \"\"\" Request details about the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. color (str): boolean to show player colors. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. flag (str): boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the players in the match. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for match details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"color\" : color , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_MATCH_ENDPOINT , params = query_params , timeout = self . timeout , ) def civs ( self , game: str = \"aoe2de\" , leaderboard_id: int = 3 , language: str = \"en\" , search: str = None , steam_id: int = None , profile_id: int = None , ) -> str: \"\"\" Request civilisations from the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for civilisations details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_CIVS_ENDPOINT , params = query_params , timeout = self . timeout , ) def map ( self , game: str = \"aoe2de\" , leaderboard_id: int = 3 , language: str = \"en\" , search: str = None , steam_id: int = None , profile_id: int = None , ) -> str: \"\"\" Request civilisations from the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Args: game (str): The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). leaderboard_id (int): Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. language (str): language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. search (str): To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. steam_id (int): To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). profile_id (int): To perform the search for a specific player, from their profile ID (ex: 459658). Raises: NightBotException: if the not one of 'search', 'steam_id' or 'profile_id' are provided. Returns: The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. \"\"\" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for civilisations details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_MAP_ENDPOINT , params = query_params , timeout = self . timeout , )","title":"AoE2NightbotAPI"},{"location":"reference/aoe2netwrapper/nightbot/#class-variables","text":"CURRENT_CIVS_ENDPOINT CURRENT_MAP_ENDPOINT CURRENT_MATCH_ENDPOINT NIGHTBOT_BASE_URL RANK_DETAILS_ENDPOINT RECENT_OPPONENT_ENDPOINT","title":"Class variables"},{"location":"reference/aoe2netwrapper/nightbot/#methods","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/nightbot/#civs","text":"def civs ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , language : str = 'en' , search : str = None , steam_id : int = None , profile_id : int = None ) -> str Request civilisations from the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None language str language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. None search str To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. None steam_id int To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). None profile_id int To perform the search for a specific player, from their profile ID (ex: 459658). None Returns: Type Description None The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. Raises: Type Description NightBotException if the not one of 'search', 'steam_id' or 'profile_id' are provided. View Source def civs ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\" \" Request civilisations from the current or last match . Either 'search' , 'steam_id' or 'profile_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). leaderboard_id ( int ): Leaderboard to extract the data for ( Unranked = 0 , 1 v1 Deathmatch = 1 , Team Deathmatch = 2 , 1 v1 Random Map = 3 , Team Random Map = 4 ). Defaults to 3 . language ( str ): language for the returned response ( 'en' , 'de' , 'el' , 'es' , 'es-MX' , 'fr' , 'hi' , 'it' , 'ja' , 'ko' , 'ms' , 'nl' , 'pt' , 'ru' , 'tr' , 'vi' , 'zh' , 'zh-TW' ). Defaults to 'en' . search ( str ): To perform the search for a specific player , from their name . Will return the highest rated player that matches the search . steam_id ( int ): To perform the search for a specific player , from their steamID64 ( ex : 76561199003184910 ). profile_id ( int ): To perform the search for a specific player , from their profile ID ( ex : 459658 ). Raises : NightBotException : if the not one of 'search' , 'steam_id' or 'profile_id' are provided . Returns : The text content of the response , as a decoded unicode string , with a quick sentence of information about the player ' s last opponent . \"\" \" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for civilisations details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_CIVS_ENDPOINT , params = query_params , timeout = self . timeout , )","title":"civs"},{"location":"reference/aoe2netwrapper/nightbot/#map","text":"def map ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , language : str = 'en' , search : str = None , steam_id : int = None , profile_id : int = None ) -> str Request civilisations from the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None language str language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. None search str To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. None steam_id int To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). None profile_id int To perform the search for a specific player, from their profile ID (ex: 459658). None Returns: Type Description None The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. Raises: Type Description NightBotException if the not one of 'search', 'steam_id' or 'profile_id' are provided. View Source def map ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\" \" Request civilisations from the current or last match . Either 'search' , 'steam_id' or 'profile_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). leaderboard_id ( int ): Leaderboard to extract the data for ( Unranked = 0 , 1 v1 Deathmatch = 1 , Team Deathmatch = 2 , 1 v1 Random Map = 3 , Team Random Map = 4 ). Defaults to 3 . language ( str ): language for the returned response ( 'en' , 'de' , 'el' , 'es' , 'es-MX' , 'fr' , 'hi' , 'it' , 'ja' , 'ko' , 'ms' , 'nl' , 'pt' , 'ru' , 'tr' , 'vi' , 'zh' , 'zh-TW' ). Defaults to 'en' . search ( str ): To perform the search for a specific player , from their name . Will return the highest rated player that matches the search . steam_id ( int ): To perform the search for a specific player , from their steamID64 ( ex : 76561199003184910 ). profile_id ( int ): To perform the search for a specific player , from their profile ID ( ex : 459658 ). Raises : NightBotException : if the not one of 'search' , 'steam_id' or 'profile_id' are provided . Returns : The text content of the response , as a decoded unicode string , with a quick sentence of information about the player ' s last opponent . \"\" \" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for civilisations details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_MAP_ENDPOINT , params = query_params , timeout = self . timeout , )","title":"map"},{"location":"reference/aoe2netwrapper/nightbot/#match","text":"def match ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , language : str = 'en' , color : str = 'true' , flag : str = 'true' , search : str = None , steam_id : int = None , profile_id : int = None ) -> str Request details about the current or last match. Either 'search', 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None language str language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. None color str boolean to show player colors. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. 'true' flag str boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. 'true' search str To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. None steam_id int To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). None profile_id int To perform the search for a specific player, from their profile ID (ex: 459658). None Returns: Type Description None The text content of the response, as a decoded unicode string, with a quick sentence of information about the players in the match. Raises: Type Description NightBotException if the not one of 'search', 'steam_id' or 'profile_id' are provided. View Source def match ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , color : str = \"true\" , flag : str = \"true\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\" \" Request details about the current or last match . Either 'search' , 'steam_id' or 'profile_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). leaderboard_id ( int ): Leaderboard to extract the data for ( Unranked = 0 , 1 v1 Deathmatch = 1 , Team Deathmatch = 2 , 1 v1 Random Map = 3 , Team Random Map = 4 ). Defaults to 3 . language ( str ): language for the returned response ( 'en' , 'de' , 'el' , 'es' , 'es-MX' , 'fr' , 'hi' , 'it' , 'ja' , 'ko' , 'ms' , 'nl' , 'pt' , 'ru' , 'tr' , 'vi' , 'zh' , 'zh-TW' ). Defaults to 'en' . color ( str ): boolean to show player colors . Defaults to 'true' . Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that . flag ( str ): boolean to show the player flag . Defaults to 'true' . Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that . search ( str ): To perform the search for a specific player , from their name . Will return the highest rated player that matches the search . steam_id ( int ): To perform the search for a specific player , from their steamID64 ( ex : 76561199003184910 ). profile_id ( int ): To perform the search for a specific player , from their profile ID ( ex : 459658 ). Raises : NightBotException : if the not one of 'search' , 'steam_id' or 'profile_id' are provided . Returns : The text content of the response , as a decoded unicode string , with a quick sentence of information about the players in the match . \"\" \" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for match details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"color\" : color , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . CURRENT_MATCH_ENDPOINT , params = query_params , timeout = self . timeout , )","title":"match"},{"location":"reference/aoe2netwrapper/nightbot/#opponent","text":"def opponent ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , language : str = 'en' , flag : str = 'true' , search : str = None , steam_id : int = None , profile_id : int = None ) -> str Request rank details about a player's most recent opponent (1v1 only). Either 'search', 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None language str language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. None flag str boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. 'true' search str To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. None steam_id int To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). None profile_id int To perform the search for a specific player, from their profile ID (ex: 459658). None Returns: Type Description None The text content of the response, as a decoded unicode string, with a quick sentence of information about the player's last opponent. Raises: Type Description NightBotException if the not one of 'search', 'steam_id' or 'profile_id' are provided. View Source def opponent ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , flag : str = \"true\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\" \" Request rank details about a player 's most recent opponent (1v1 only). Either ' search ' , 'steam_id' or 'profile_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). leaderboard_id ( int ): Leaderboard to extract the data for ( Unranked = 0 , 1 v1 Deathmatch = 1 , Team Deathmatch = 2 , 1 v1 Random Map = 3 , Team Random Map = 4 ). Defaults to 3 . language ( str ): language for the returned response ( 'en' , 'de' , 'el' , 'es' , 'es-MX' , 'fr' , 'hi' , 'it' , 'ja' , 'ko' , 'ms' , 'nl' , 'pt' , 'ru' , 'tr' , 'vi' , 'zh' , 'zh-TW' ). Defaults to 'en' . flag ( str ): boolean to show the player flag . Defaults to 'true' . Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that . search ( str ): To perform the search for a specific player , from their name . Will return the highest rated player that matches the search . steam_id ( int ): To perform the search for a specific player , from their steamID64 ( ex : 76561199003184910 ). profile_id ( int ): To perform the search for a specific player , from their profile ID ( ex : 459658 ). Raises : NightBotException : if the not one of 'search' , 'steam_id' or 'profile_id' are provided . Returns : The text content of the response , as a decoded unicode string , with a quick sentence of information about the player ' s last opponent . \"\" \" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for opponent details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . RECENT_OPPONENT_ENDPOINT , params = query_params , timeout = self . timeout , )","title":"opponent"},{"location":"reference/aoe2netwrapper/nightbot/#rank","text":"def rank ( self , game : str = 'aoe2de' , leaderboard_id : int = 3 , language : str = 'en' , flag : str = 'true' , search : str = None , steam_id : int = None , profile_id : int = None ) -> str Request rank details about a player. Either 'search', 'steam_id' or 'profile_id' required. Parameters: Name Type Description Default game str The game for which to extract the list of strings. Defaults to 'aoe2de'. Possibilities are 'aoe2hd' (Age of Empires 2: HD Edition) and 'aoe2de' (Age of Empires 2: Definitive Edition). 'aoe2de' leaderboard_id int Leaderboard to extract the data for (Unranked=0, 1v1 Deathmatch=1, Team Deathmatch=2, 1v1 Random Map=3, Team Random Map=4). Defaults to 3. None language str language for the returned response ('en', 'de', 'el', 'es', 'es-MX', 'fr', 'hi', 'it', 'ja', 'ko', 'ms', 'nl', 'pt', 'ru', 'tr', 'vi', 'zh', 'zh-TW'). Defaults to 'en'. None flag str boolean to show the player flag. Defaults to 'true'. Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that. 'true' search str To perform the search for a specific player, from their name. Will return the highest rated player that matches the search. None steam_id int To perform the search for a specific player, from their steamID64 (ex: 76561199003184910). None profile_id int To perform the search for a specific player, from their profile ID (ex: 459658). None Returns: Type Description None The text content of the response, as a decoded unicode string, with a quick sentence of information about the player. Raises: Type Description NightBotException if the not one of 'search', 'steam_id' or 'profile_id' are provided. View Source def rank ( self , game : str = \"aoe2de\" , leaderboard_id : int = 3 , language : str = \"en\" , flag : str = \"true\" , search : str = None , steam_id : int = None , profile_id : int = None , ) -> str : \"\" \" Request rank details about a player . Either 'search' , 'steam_id' or 'profile_id' required . Args : game ( str ): The game for which to extract the list of strings . Defaults to 'aoe2de' . Possibilities are 'aoe2hd' ( Age of Empires 2 : HD Edition ) and 'aoe2de' ( Age of Empires 2 : Definitive Edition ). leaderboard_id ( int ): Leaderboard to extract the data for ( Unranked = 0 , 1 v1 Deathmatch = 1 , Team Deathmatch = 2 , 1 v1 Random Map = 3 , Team Random Map = 4 ). Defaults to 3 . language ( str ): language for the returned response ( 'en' , 'de' , 'el' , 'es' , 'es-MX' , 'fr' , 'hi' , 'it' , 'ja' , 'ko' , 'ms' , 'nl' , 'pt' , 'ru' , 'tr' , 'vi' , 'zh' , 'zh-TW' ). Defaults to 'en' . flag ( str ): boolean to show the player flag . Defaults to 'true' . Needs to be a string for now since requests transforms True boolean to 'True' and the API rejects that . search ( str ): To perform the search for a specific player , from their name . Will return the highest rated player that matches the search . steam_id ( int ): To perform the search for a specific player , from their steamID64 ( ex : 76561199003184910 ). profile_id ( int ): To perform the search for a specific player , from their profile ID ( ex : 459658 ). Raises : NightBotException : if the not one of 'search' , 'steam_id' or 'profile_id' are provided . Returns : The text content of the response , as a decoded unicode string , with a quick sentence of information about the player . \"\" \" if not any (( search , steam_id , profile_id )): logger . error ( \"Missing one of 'search', 'steam_id', 'profile_id'.\" ) raise NightBotException ( \"Either 'search', 'steam_id' or 'profile_id' required, please provide one.\" ) logger . debug ( \"Preparing parameters for rank details query\" ) query_params = { \"game\" : game , \"leaderboard_id\" : leaderboard_id , \"language\" : language , \"flag\" : flag , \"search\" : search , \"steam_id\" : steam_id , \"profile_id\" : profile_id , } return _get_request_text_response_decoded ( session = self . session , url = self . RANK_DETAILS_ENDPOINT , params = query_params , timeout = self . timeout , )","title":"rank"},{"location":"reference/aoe2netwrapper/models/","text":"Module aoe2netwrapper.models aoe2netwrapper.models This subpackage contains the model objects used to encapsulate responses from the API. Each module therein contains the models for a specific API endpoint. View Source \"\"\" aoe2netwrapper.models --------------------- This subpackage contains the model objects used to encapsulate responses from the API. Each module therein contains the models for a specific API endpoint. \"\"\" from .last_match import LastMatchResponse from .leaderboard import LeaderBoardResponse from .lobbies import MatchLobby from .match import MatchLobby from .match_history import MatchLobby from .matches import MatchLobby from .num_online import NumOnlineResponse from .rating_history import RatingTimePoint from .strings import StringsResponse Sub-modules aoe2netwrapper.models.last_match aoe2netwrapper.models.leaderboard aoe2netwrapper.models.lobbies aoe2netwrapper.models.match aoe2netwrapper.models.match_history aoe2netwrapper.models.matches aoe2netwrapper.models.num_online aoe2netwrapper.models.rating_history aoe2netwrapper.models.strings","title":"Index"},{"location":"reference/aoe2netwrapper/models/#module-aoe2netwrappermodels","text":"aoe2netwrapper.models This subpackage contains the model objects used to encapsulate responses from the API. Each module therein contains the models for a specific API endpoint. View Source \"\"\" aoe2netwrapper.models --------------------- This subpackage contains the model objects used to encapsulate responses from the API. Each module therein contains the models for a specific API endpoint. \"\"\" from .last_match import LastMatchResponse from .leaderboard import LeaderBoardResponse from .lobbies import MatchLobby from .match import MatchLobby from .match_history import MatchLobby from .matches import MatchLobby from .num_online import NumOnlineResponse from .rating_history import RatingTimePoint from .strings import StringsResponse","title":"Module aoe2netwrapper.models"},{"location":"reference/aoe2netwrapper/models/#sub-modules","text":"aoe2netwrapper.models.last_match aoe2netwrapper.models.leaderboard aoe2netwrapper.models.lobbies aoe2netwrapper.models.match aoe2netwrapper.models.match_history aoe2netwrapper.models.matches aoe2netwrapper.models.num_online aoe2netwrapper.models.rating_history aoe2netwrapper.models.strings","title":"Sub-modules"},{"location":"reference/aoe2netwrapper/models/last_match/","text":"Module aoe2netwrapper.models.last_match aoe2netwrapper.models.lobbies This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/lobbies View Source \"\"\" aoe2netwrapper.models.lobbies ----------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/lobbies \"\"\" from typing import Optional from pydantic import BaseModel , Field from aoe2netwrapper.models.lobbies import MatchLobby class LastMatchResponse ( BaseModel ): \"\"\"An object to encapsulate the response from the last_match API.\"\"\" profile_id : Optional [ int ] = Field ( None , description = \"The ID attributed to the player by AoE II\" ) steam_id : Optional [ int ] = Field ( None , description = \"ID of the player on the Steam platform\" ) name : Optional [ str ] = Field ( None , description = \"Name of the player the query was made for\" ) country : Optional [ str ] = Field ( None , description = \"Country the player connected from\" ) last_match : Optional [ MatchLobby ] = Field ( None , description = \"MatchLobby of the last match\" ) Classes LastMatchResponse class LastMatchResponse ( __pydantic_self__ , ** data : Any ) View Source class LastMatchResponse ( BaseModel ) : \"\"\"An object to encapsulate the response from the last_match API.\"\"\" profile_id : Optional [ int ] = Field ( None , description = \"The ID attributed to the player by AoE II\" ) steam_id : Optional [ int ] = Field ( None , description = \"ID of the player on the Steam platform\" ) name : Optional [ str ] = Field ( None , description = \"Name of the player the query was made for\" ) country : Optional [ str ] = Field ( None , description = \"Country the player connected from\" ) last_match : Optional [ MatchLobby ] = Field ( None , description = \"MatchLobby of the last match\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"Last Match"},{"location":"reference/aoe2netwrapper/models/last_match/#module-aoe2netwrappermodelslast_match","text":"aoe2netwrapper.models.lobbies This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/lobbies View Source \"\"\" aoe2netwrapper.models.lobbies ----------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/lobbies \"\"\" from typing import Optional from pydantic import BaseModel , Field from aoe2netwrapper.models.lobbies import MatchLobby class LastMatchResponse ( BaseModel ): \"\"\"An object to encapsulate the response from the last_match API.\"\"\" profile_id : Optional [ int ] = Field ( None , description = \"The ID attributed to the player by AoE II\" ) steam_id : Optional [ int ] = Field ( None , description = \"ID of the player on the Steam platform\" ) name : Optional [ str ] = Field ( None , description = \"Name of the player the query was made for\" ) country : Optional [ str ] = Field ( None , description = \"Country the player connected from\" ) last_match : Optional [ MatchLobby ] = Field ( None , description = \"MatchLobby of the last match\" )","title":"Module aoe2netwrapper.models.last_match"},{"location":"reference/aoe2netwrapper/models/last_match/#classes","text":"","title":"Classes"},{"location":"reference/aoe2netwrapper/models/last_match/#lastmatchresponse","text":"class LastMatchResponse ( __pydantic_self__ , ** data : Any ) View Source class LastMatchResponse ( BaseModel ) : \"\"\"An object to encapsulate the response from the last_match API.\"\"\" profile_id : Optional [ int ] = Field ( None , description = \"The ID attributed to the player by AoE II\" ) steam_id : Optional [ int ] = Field ( None , description = \"ID of the player on the Steam platform\" ) name : Optional [ str ] = Field ( None , description = \"Name of the player the query was made for\" ) country : Optional [ str ] = Field ( None , description = \"Country the player connected from\" ) last_match : Optional [ MatchLobby ] = Field ( None , description = \"MatchLobby of the last match\" )","title":"LastMatchResponse"},{"location":"reference/aoe2netwrapper/models/last_match/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/last_match/#class-variables","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/last_match/#static-methods","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/last_match/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/last_match/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/last_match/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/last_match/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/last_match/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/last_match/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/last_match/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/last_match/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/last_match/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/last_match/#instance-variables","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/last_match/#methods","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/last_match/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/last_match/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/last_match/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/last_match/#to_string","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/leaderboard/","text":"Module aoe2netwrapper.models.leaderboard aoe2netwrapper.models.leaderboard This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/leaderboard View Source \"\"\" aoe2netwrapper.models.leaderboard --------------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/leaderboard \"\"\" from typing import Any , List , Optional from pydantic import BaseModel , Field class LeaderBoardSpot ( BaseModel ): \"\"\"An object to encapsulate any entry in the leaderboard ranking.\"\"\" profile_id : Optional [ int ] = Field ( None , description = \"The ID attributed to the player by AoE II\" ) rank : Optional [ int ] = Field ( None , description = \"The player's rank on the ladder\" ) rating : Optional [ int ] = Field ( None , description = \"The player's rating in the ELO system\" ) steam_id : Optional [ int ] = Field ( None , description = \"ID of the player on the Steam platform\" ) icon : Optional [ Any ] = Field ( None , description = \"The player's icon\" ) name : Optional [ str ] = Field ( None , description = \"The player's in-game name\" ) clan : Optional [ str ] = Field ( None , description = \"The player's clan / team\" ) country : Optional [ str ] = Field ( None , description = \"Country the player connected from\" ) previous_rating : Optional [ int ] = Field ( None , description = \"Player's rating at their last match\" ) highest_rating : Optional [ int ] = Field ( None , description = \"Highest rating achieved by the player\" ) streak : Optional [ int ] = Field ( None , description = \"Current number of consecutive wins\" ) lowest_streak : Optional [ int ] = Field ( None , description = \"Lowest streak achieved by this player\" ) highest_streak : Optional [ int ] = Field ( None , description = \"Highest streak achieved by this player\" ) games : Optional [ int ] = Field ( None , description = \"The total amount of games played by the player\" ) wins : Optional [ int ] = Field ( None , description = \"Total amount of wins\" ) losses : Optional [ int ] = Field ( None , description = \"Total amount of losses\" ) drops : Optional [ int ] = Field ( None , description = \"Number of games the player dropped out of\" ) last_match : Optional [ int ] = Field ( None , description = \"Timestamp of the last game played\" ) last_match_time : Optional [ int ] = Field ( None , description = \"Timestamp of the last game played\" ) class LeaderBoardResponse ( BaseModel ): \"\"\"An object to encapsulate the response from the leaderboard API.\"\"\" total : Optional [ int ] = Field ( None , description = \"Total number of entries in the leaderboard\" ) leaderboard_id : Optional [ int ] = Field ( None , description = \"ID of the leaderboard queried, aka game type\" ) start : Optional [ int ] = Field ( None , description = \"Starting rank of the first entry in the response\" ) count : Optional [ int ] = Field ( None , description = \"Number of entries returned\" ) leaderboard : Optional [ List [ LeaderBoardSpot ]] = Field ( None , description = \"List of LeaderBoardSport entries\" ) Classes LeaderBoardResponse class LeaderBoardResponse ( __pydantic_self__ , ** data : Any ) View Source class LeaderBoardResponse ( BaseModel ) : \"\"\"An object to encapsulate the response from the leaderboard API.\"\"\" total : Optional [ int ] = Field ( None , description = \"Total number of entries in the leaderboard\" ) leaderboard_id : Optional [ int ] = Field ( None , description = \"ID of the leaderboard queried, aka game type\" ) start : Optional [ int ] = Field ( None , description = \"Starting rank of the first entry in the response\" ) count : Optional [ int ] = Field ( None , description = \"Number of entries returned\" ) leaderboard : Optional [ List[LeaderBoardSpot ] ] = Field ( None , description = \"List of LeaderBoardSport entries\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' LeaderBoardSpot class LeaderBoardSpot ( __pydantic_self__ , ** data : Any ) View Source class LeaderBoardSpot ( BaseModel ) : \"\"\"An object to encapsulate any entry in the leaderboard ranking.\"\"\" profile_id : Optional [ int ] = Field ( None , description = \"The ID attributed to the player by AoE II\" ) rank : Optional [ int ] = Field ( None , description = \"The player's rank on the ladder\" ) rating : Optional [ int ] = Field ( None , description = \"The player's rating in the ELO system\" ) steam_id : Optional [ int ] = Field ( None , description = \"ID of the player on the Steam platform\" ) icon : Optional [ Any ] = Field ( None , description = \"The player's icon\" ) name : Optional [ str ] = Field ( None , description = \"The player's in-game name\" ) clan : Optional [ str ] = Field ( None , description = \"The player's clan / team\" ) country : Optional [ str ] = Field ( None , description = \"Country the player connected from\" ) previous_rating : Optional [ int ] = Field ( None , description = \"Player's rating at their last match\" ) highest_rating : Optional [ int ] = Field ( None , description = \"Highest rating achieved by the player\" ) streak : Optional [ int ] = Field ( None , description = \"Current number of consecutive wins\" ) lowest_streak : Optional [ int ] = Field ( None , description = \"Lowest streak achieved by this player\" ) highest_streak : Optional [ int ] = Field ( None , description = \"Highest streak achieved by this player\" ) games : Optional [ int ] = Field ( None , description = \"The total amount of games played by the player\" ) wins : Optional [ int ] = Field ( None , description = \"Total amount of wins\" ) losses : Optional [ int ] = Field ( None , description = \"Total amount of losses\" ) drops : Optional [ int ] = Field ( None , description = \"Number of games the player dropped out of\" ) last_match : Optional [ int ] = Field ( None , description = \"Timestamp of the last game played\" ) last_match_time : Optional [ int ] = Field ( None , description = \"Timestamp of the last game played\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"Leaderboard"},{"location":"reference/aoe2netwrapper/models/leaderboard/#module-aoe2netwrappermodelsleaderboard","text":"aoe2netwrapper.models.leaderboard This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/leaderboard View Source \"\"\" aoe2netwrapper.models.leaderboard --------------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/leaderboard \"\"\" from typing import Any , List , Optional from pydantic import BaseModel , Field class LeaderBoardSpot ( BaseModel ): \"\"\"An object to encapsulate any entry in the leaderboard ranking.\"\"\" profile_id : Optional [ int ] = Field ( None , description = \"The ID attributed to the player by AoE II\" ) rank : Optional [ int ] = Field ( None , description = \"The player's rank on the ladder\" ) rating : Optional [ int ] = Field ( None , description = \"The player's rating in the ELO system\" ) steam_id : Optional [ int ] = Field ( None , description = \"ID of the player on the Steam platform\" ) icon : Optional [ Any ] = Field ( None , description = \"The player's icon\" ) name : Optional [ str ] = Field ( None , description = \"The player's in-game name\" ) clan : Optional [ str ] = Field ( None , description = \"The player's clan / team\" ) country : Optional [ str ] = Field ( None , description = \"Country the player connected from\" ) previous_rating : Optional [ int ] = Field ( None , description = \"Player's rating at their last match\" ) highest_rating : Optional [ int ] = Field ( None , description = \"Highest rating achieved by the player\" ) streak : Optional [ int ] = Field ( None , description = \"Current number of consecutive wins\" ) lowest_streak : Optional [ int ] = Field ( None , description = \"Lowest streak achieved by this player\" ) highest_streak : Optional [ int ] = Field ( None , description = \"Highest streak achieved by this player\" ) games : Optional [ int ] = Field ( None , description = \"The total amount of games played by the player\" ) wins : Optional [ int ] = Field ( None , description = \"Total amount of wins\" ) losses : Optional [ int ] = Field ( None , description = \"Total amount of losses\" ) drops : Optional [ int ] = Field ( None , description = \"Number of games the player dropped out of\" ) last_match : Optional [ int ] = Field ( None , description = \"Timestamp of the last game played\" ) last_match_time : Optional [ int ] = Field ( None , description = \"Timestamp of the last game played\" ) class LeaderBoardResponse ( BaseModel ): \"\"\"An object to encapsulate the response from the leaderboard API.\"\"\" total : Optional [ int ] = Field ( None , description = \"Total number of entries in the leaderboard\" ) leaderboard_id : Optional [ int ] = Field ( None , description = \"ID of the leaderboard queried, aka game type\" ) start : Optional [ int ] = Field ( None , description = \"Starting rank of the first entry in the response\" ) count : Optional [ int ] = Field ( None , description = \"Number of entries returned\" ) leaderboard : Optional [ List [ LeaderBoardSpot ]] = Field ( None , description = \"List of LeaderBoardSport entries\" )","title":"Module aoe2netwrapper.models.leaderboard"},{"location":"reference/aoe2netwrapper/models/leaderboard/#classes","text":"","title":"Classes"},{"location":"reference/aoe2netwrapper/models/leaderboard/#leaderboardresponse","text":"class LeaderBoardResponse ( __pydantic_self__ , ** data : Any ) View Source class LeaderBoardResponse ( BaseModel ) : \"\"\"An object to encapsulate the response from the leaderboard API.\"\"\" total : Optional [ int ] = Field ( None , description = \"Total number of entries in the leaderboard\" ) leaderboard_id : Optional [ int ] = Field ( None , description = \"ID of the leaderboard queried, aka game type\" ) start : Optional [ int ] = Field ( None , description = \"Starting rank of the first entry in the response\" ) count : Optional [ int ] = Field ( None , description = \"Number of entries returned\" ) leaderboard : Optional [ List[LeaderBoardSpot ] ] = Field ( None , description = \"List of LeaderBoardSport entries\" )","title":"LeaderBoardResponse"},{"location":"reference/aoe2netwrapper/models/leaderboard/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/leaderboard/#class-variables","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/leaderboard/#static-methods","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/leaderboard/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/leaderboard/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/leaderboard/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/leaderboard/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/leaderboard/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/leaderboard/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/leaderboard/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/leaderboard/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/leaderboard/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/leaderboard/#instance-variables","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/leaderboard/#methods","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/leaderboard/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/leaderboard/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/leaderboard/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/leaderboard/#to_string","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/leaderboard/#leaderboardspot","text":"class LeaderBoardSpot ( __pydantic_self__ , ** data : Any ) View Source class LeaderBoardSpot ( BaseModel ) : \"\"\"An object to encapsulate any entry in the leaderboard ranking.\"\"\" profile_id : Optional [ int ] = Field ( None , description = \"The ID attributed to the player by AoE II\" ) rank : Optional [ int ] = Field ( None , description = \"The player's rank on the ladder\" ) rating : Optional [ int ] = Field ( None , description = \"The player's rating in the ELO system\" ) steam_id : Optional [ int ] = Field ( None , description = \"ID of the player on the Steam platform\" ) icon : Optional [ Any ] = Field ( None , description = \"The player's icon\" ) name : Optional [ str ] = Field ( None , description = \"The player's in-game name\" ) clan : Optional [ str ] = Field ( None , description = \"The player's clan / team\" ) country : Optional [ str ] = Field ( None , description = \"Country the player connected from\" ) previous_rating : Optional [ int ] = Field ( None , description = \"Player's rating at their last match\" ) highest_rating : Optional [ int ] = Field ( None , description = \"Highest rating achieved by the player\" ) streak : Optional [ int ] = Field ( None , description = \"Current number of consecutive wins\" ) lowest_streak : Optional [ int ] = Field ( None , description = \"Lowest streak achieved by this player\" ) highest_streak : Optional [ int ] = Field ( None , description = \"Highest streak achieved by this player\" ) games : Optional [ int ] = Field ( None , description = \"The total amount of games played by the player\" ) wins : Optional [ int ] = Field ( None , description = \"Total amount of wins\" ) losses : Optional [ int ] = Field ( None , description = \"Total amount of losses\" ) drops : Optional [ int ] = Field ( None , description = \"Number of games the player dropped out of\" ) last_match : Optional [ int ] = Field ( None , description = \"Timestamp of the last game played\" ) last_match_time : Optional [ int ] = Field ( None , description = \"Timestamp of the last game played\" )","title":"LeaderBoardSpot"},{"location":"reference/aoe2netwrapper/models/leaderboard/#ancestors-in-mro_1","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/leaderboard/#class-variables_1","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/leaderboard/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/leaderboard/#construct_1","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/leaderboard/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/leaderboard/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/leaderboard/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/leaderboard/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/leaderboard/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/leaderboard/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/leaderboard/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/leaderboard/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/leaderboard/#instance-variables_1","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/leaderboard/#methods_1","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/leaderboard/#copy_1","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/leaderboard/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/leaderboard/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/leaderboard/#to_string_1","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/lobbies/","text":"Module aoe2netwrapper.models.lobbies aoe2netwrapper.models.lobbies This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/lobbies View Source \"\"\" aoe2netwrapper.models.lobbies ----------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/lobbies \"\"\" from typing import Any , List , Optional from pydantic import BaseModel , Field class LobbyMember ( BaseModel ): \"\"\"An object to encapsulate any entry in the leaderboard ranking.\"\"\" profile_id : Optional [ int ] = Field ( None , description = \"The ID attributed to the member by AoE II\" ) steam_id : Optional [ int ] = Field ( None , description = \"ID of the member on the Steam platform\" ) name : Optional [ str ] = Field ( None , description = \"The member's in-game name\" ) clan : Optional [ str ] = Field ( None , description = \"The member's clan / team\" ) country : Optional [ str ] = Field ( None , description = \"Country the player connected from\" ) slot : Optional [ int ] = Field ( None , description = \"Slot number of the member in the lobby\" ) slot_type : Optional [ int ] = Field ( None , description = \"ID of the role of the member in the lobby\" ) rating : Optional [ int ] = Field ( None , description = \"The member's rating in the ELO system\" ) rating_change : Optional [ Any ] = Field ( None , description = \"The difference to the member's previous rating\" ) games : Optional [ int ] = Field ( None , description = \"The total amount of games played by the member\" ) wins : Optional [ int ] = Field ( None , description = \"Total amount of wins of the member\" ) streak : Optional [ int ] = Field ( None , description = \"Current number of consecutive wins of the member\" ) drops : Optional [ int ] = Field ( None , description = \"Number of games the member dropped out of\" ) color : Optional [ str ] = Field ( None , description = \"The member's in-game color\" ) team : Optional [ str ] = Field ( None , description = \"The member's team number for the game\" ) civ : Optional [ int ] = Field ( None , description = \"The member's civilization pick for the game\" ) won : Optional [ int ] = Field ( None , description = \"Unclear\" ) class MatchLobby ( BaseModel ): \"\"\"An object to encapsulate any entry in the list of returned lobbies.\"\"\" match_id : Optional [ int ] = Field ( None , description = \"ID attributed to the match this lobby is for\" ) lobby_id : Optional [ int ] = Field ( None , description = \"ID attributed to the lobby itself\" ) match_uuid : Optional [ str ] = Field ( None , description = \"UUID attributed to the match this lobby is for\" ) version : Optional [ int ] = Field ( None , description = \"Version number of the game patch\" ) name : Optional [ str ] = Field ( None , description = \"Name given to the lobby\" ) num_players : Optional [ int ] = Field ( None , description = \"Number of players in the lobby\" ) num_slots : Optional [ int ] = Field ( None , description = \"Number of player slots in the lobby\" ) average_rating : Optional [ int ] = Field ( None , description = \"Average rating of the members in the lobby\" ) cheats : Optional [ bool ] = Field ( None , description = \"Whether cheats are enabled\" ) full_tech_tree : Optional [ bool ] = Field ( None , description = \"Whether the full tech tree is set unlocked\" ) ending_age : Optional [ int ] = Field ( None , description = \"The last attainable age for the game\" ) expansion : Optional [ str ] = Field ( None , description = \"The expansion patch enabled\" ) game_type : Optional [ int ] = Field ( None , description = \"ID of the game type, same a leaderboard IDs\" ) has_custom_content : Optional [ bool ] = Field ( None , description = \"Whether the game has custom content\" ) has_password : Optional [ bool ] = Field ( None , description = \"Whether the lobby is password-protected\" ) lock_speed : Optional [ bool ] = Field ( None , description = \"Whether the game speed setting is locked\" ) lock_teams : Optional [ bool ] = Field ( None , description = \"Whether the player teams are locked\" ) map_size : Optional [ int ] = Field ( None , description = \"The game's map size setting\" ) map_type : Optional [ int ] = Field ( None , description = \"ID of the game's map type\" ) pop : Optional [ int ] = Field ( None , description = \"The max population setting for the game\" ) ranked : Optional [ bool ] = Field ( None , description = \"Whether the lobby is for a ranked game\" ) leaderboard_id : Optional [ int ] = Field ( None , description = \"Leaderboard ID for the game type\" ) rating_type : Optional [ int ] = Field ( None , description = \"The rating ID for the game\" ) resources : Optional [ int ] = Field ( None , description = \"The setting for players' starting resources\" ) rms : Optional [ str ] = Field ( None , description = \"Unclear\" ) scenario : Optional [ str ] = Field ( None , description = \"The activated scenario for the game\" ) server : Optional [ str ] = Field ( None , description = \"The server hosting the game\" ) shared_exploration : Optional [ bool ] = Field ( None , description = \"Whether the map exploration is shared\" ) speed : Optional [ int ] = Field ( None , description = \"The game speed\" ) starting_age : Optional [ int ] = Field ( None , description = \"The starting age for the game\" ) team_together : Optional [ bool ] = Field ( None , description = \"Whether players can team up\" ) team_positions : Optional [ bool ] = Field ( None , description = \"Whether players start with team positions\" ) treaty_length : Optional [ int ] = Field ( None , description = \"Duration of the 'no attack' treaty in minutes\" ) turbo : Optional [ bool ] = Field ( None , description = \"Whether the game will be played in turbo mode\" ) victory : Optional [ int ] = Field ( None , description = \"ID of the game's victory condition\" ) victory_time : Optional [ int ] = Field ( None , description = \"Setting of the victory time limit\" ) visibility : Optional [ int ] = Field ( None , description = \"ID of the visibility setting\" ) opened : Optional [ int ] = Field ( None , description = \"Timestamp of the lobby's creation\" ) started : Optional [ Any ] = Field ( None , description = \"Timestamp of the game's start\" ) finished : Optional [ Any ] = Field ( None , description = \"Timestamp of the game's end\" ) players : Optional [ List [ LobbyMember ]] = Field ( None , description = \"List of members in the lobby\" ) Classes LobbyMember class LobbyMember ( __pydantic_self__ , ** data : Any ) View Source class LobbyMember ( BaseModel ) : \"\"\"An object to encapsulate any entry in the leaderboard ranking.\"\"\" profile_id : Optional [ int ] = Field ( None , description = \"The ID attributed to the member by AoE II\" ) steam_id : Optional [ int ] = Field ( None , description = \"ID of the member on the Steam platform\" ) name : Optional [ str ] = Field ( None , description = \"The member's in-game name\" ) clan : Optional [ str ] = Field ( None , description = \"The member's clan / team\" ) country : Optional [ str ] = Field ( None , description = \"Country the player connected from\" ) slot : Optional [ int ] = Field ( None , description = \"Slot number of the member in the lobby\" ) slot_type : Optional [ int ] = Field ( None , description = \"ID of the role of the member in the lobby\" ) rating : Optional [ int ] = Field ( None , description = \"The member's rating in the ELO system\" ) rating_change : Optional [ Any ] = Field ( None , description = \"The difference to the member's previous rating\" ) games : Optional [ int ] = Field ( None , description = \"The total amount of games played by the member\" ) wins : Optional [ int ] = Field ( None , description = \"Total amount of wins of the member\" ) streak : Optional [ int ] = Field ( None , description = \"Current number of consecutive wins of the member\" ) drops : Optional [ int ] = Field ( None , description = \"Number of games the member dropped out of\" ) color : Optional [ str ] = Field ( None , description = \"The member's in-game color\" ) team : Optional [ str ] = Field ( None , description = \"The member's team number for the game\" ) civ : Optional [ int ] = Field ( None , description = \"The member's civilization pick for the game\" ) won : Optional [ int ] = Field ( None , description = \"Unclear\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' MatchLobby class MatchLobby ( __pydantic_self__ , ** data : Any ) View Source class MatchLobby ( BaseModel ) : \"\"\"An object to encapsulate any entry in the list of returned lobbies.\"\"\" match_id : Optional [ int ] = Field ( None , description = \"ID attributed to the match this lobby is for\" ) lobby_id : Optional [ int ] = Field ( None , description = \"ID attributed to the lobby itself\" ) match_uuid : Optional [ str ] = Field ( None , description = \"UUID attributed to the match this lobby is for\" ) version : Optional [ int ] = Field ( None , description = \"Version number of the game patch\" ) name : Optional [ str ] = Field ( None , description = \"Name given to the lobby\" ) num_players : Optional [ int ] = Field ( None , description = \"Number of players in the lobby\" ) num_slots : Optional [ int ] = Field ( None , description = \"Number of player slots in the lobby\" ) average_rating : Optional [ int ] = Field ( None , description = \"Average rating of the members in the lobby\" ) cheats : Optional [ bool ] = Field ( None , description = \"Whether cheats are enabled\" ) full_tech_tree : Optional [ bool ] = Field ( None , description = \"Whether the full tech tree is set unlocked\" ) ending_age : Optional [ int ] = Field ( None , description = \"The last attainable age for the game\" ) expansion : Optional [ str ] = Field ( None , description = \"The expansion patch enabled\" ) game_type : Optional [ int ] = Field ( None , description = \"ID of the game type, same a leaderboard IDs\" ) has_custom_content : Optional [ bool ] = Field ( None , description = \"Whether the game has custom content\" ) has_password : Optional [ bool ] = Field ( None , description = \"Whether the lobby is password-protected\" ) lock_speed : Optional [ bool ] = Field ( None , description = \"Whether the game speed setting is locked\" ) lock_teams : Optional [ bool ] = Field ( None , description = \"Whether the player teams are locked\" ) map_size : Optional [ int ] = Field ( None , description = \"The game's map size setting\" ) map_type : Optional [ int ] = Field ( None , description = \"ID of the game's map type\" ) pop : Optional [ int ] = Field ( None , description = \"The max population setting for the game\" ) ranked : Optional [ bool ] = Field ( None , description = \"Whether the lobby is for a ranked game\" ) leaderboard_id : Optional [ int ] = Field ( None , description = \"Leaderboard ID for the game type\" ) rating_type : Optional [ int ] = Field ( None , description = \"The rating ID for the game\" ) resources : Optional [ int ] = Field ( None , description = \"The setting for players' starting resources\" ) rms : Optional [ str ] = Field ( None , description = \"Unclear\" ) scenario : Optional [ str ] = Field ( None , description = \"The activated scenario for the game\" ) server : Optional [ str ] = Field ( None , description = \"The server hosting the game\" ) shared_exploration : Optional [ bool ] = Field ( None , description = \"Whether the map exploration is shared\" ) speed : Optional [ int ] = Field ( None , description = \"The game speed\" ) starting_age : Optional [ int ] = Field ( None , description = \"The starting age for the game\" ) team_together : Optional [ bool ] = Field ( None , description = \"Whether players can team up\" ) team_positions : Optional [ bool ] = Field ( None , description = \"Whether players start with team positions\" ) treaty_length : Optional [ int ] = Field ( None , description = \"Duration of the 'no attack' treaty in minutes\" ) turbo : Optional [ bool ] = Field ( None , description = \"Whether the game will be played in turbo mode\" ) victory : Optional [ int ] = Field ( None , description = \"ID of the game's victory condition\" ) victory_time : Optional [ int ] = Field ( None , description = \"Setting of the victory time limit\" ) visibility : Optional [ int ] = Field ( None , description = \"ID of the visibility setting\" ) opened : Optional [ int ] = Field ( None , description = \"Timestamp of the lobby's creation\" ) started : Optional [ Any ] = Field ( None , description = \"Timestamp of the game's start\" ) finished : Optional [ Any ] = Field ( None , description = \"Timestamp of the game's end\" ) players : Optional [ List[LobbyMember ] ] = Field ( None , description = \"List of members in the lobby\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"Lobbies"},{"location":"reference/aoe2netwrapper/models/lobbies/#module-aoe2netwrappermodelslobbies","text":"aoe2netwrapper.models.lobbies This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/lobbies View Source \"\"\" aoe2netwrapper.models.lobbies ----------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/lobbies \"\"\" from typing import Any , List , Optional from pydantic import BaseModel , Field class LobbyMember ( BaseModel ): \"\"\"An object to encapsulate any entry in the leaderboard ranking.\"\"\" profile_id : Optional [ int ] = Field ( None , description = \"The ID attributed to the member by AoE II\" ) steam_id : Optional [ int ] = Field ( None , description = \"ID of the member on the Steam platform\" ) name : Optional [ str ] = Field ( None , description = \"The member's in-game name\" ) clan : Optional [ str ] = Field ( None , description = \"The member's clan / team\" ) country : Optional [ str ] = Field ( None , description = \"Country the player connected from\" ) slot : Optional [ int ] = Field ( None , description = \"Slot number of the member in the lobby\" ) slot_type : Optional [ int ] = Field ( None , description = \"ID of the role of the member in the lobby\" ) rating : Optional [ int ] = Field ( None , description = \"The member's rating in the ELO system\" ) rating_change : Optional [ Any ] = Field ( None , description = \"The difference to the member's previous rating\" ) games : Optional [ int ] = Field ( None , description = \"The total amount of games played by the member\" ) wins : Optional [ int ] = Field ( None , description = \"Total amount of wins of the member\" ) streak : Optional [ int ] = Field ( None , description = \"Current number of consecutive wins of the member\" ) drops : Optional [ int ] = Field ( None , description = \"Number of games the member dropped out of\" ) color : Optional [ str ] = Field ( None , description = \"The member's in-game color\" ) team : Optional [ str ] = Field ( None , description = \"The member's team number for the game\" ) civ : Optional [ int ] = Field ( None , description = \"The member's civilization pick for the game\" ) won : Optional [ int ] = Field ( None , description = \"Unclear\" ) class MatchLobby ( BaseModel ): \"\"\"An object to encapsulate any entry in the list of returned lobbies.\"\"\" match_id : Optional [ int ] = Field ( None , description = \"ID attributed to the match this lobby is for\" ) lobby_id : Optional [ int ] = Field ( None , description = \"ID attributed to the lobby itself\" ) match_uuid : Optional [ str ] = Field ( None , description = \"UUID attributed to the match this lobby is for\" ) version : Optional [ int ] = Field ( None , description = \"Version number of the game patch\" ) name : Optional [ str ] = Field ( None , description = \"Name given to the lobby\" ) num_players : Optional [ int ] = Field ( None , description = \"Number of players in the lobby\" ) num_slots : Optional [ int ] = Field ( None , description = \"Number of player slots in the lobby\" ) average_rating : Optional [ int ] = Field ( None , description = \"Average rating of the members in the lobby\" ) cheats : Optional [ bool ] = Field ( None , description = \"Whether cheats are enabled\" ) full_tech_tree : Optional [ bool ] = Field ( None , description = \"Whether the full tech tree is set unlocked\" ) ending_age : Optional [ int ] = Field ( None , description = \"The last attainable age for the game\" ) expansion : Optional [ str ] = Field ( None , description = \"The expansion patch enabled\" ) game_type : Optional [ int ] = Field ( None , description = \"ID of the game type, same a leaderboard IDs\" ) has_custom_content : Optional [ bool ] = Field ( None , description = \"Whether the game has custom content\" ) has_password : Optional [ bool ] = Field ( None , description = \"Whether the lobby is password-protected\" ) lock_speed : Optional [ bool ] = Field ( None , description = \"Whether the game speed setting is locked\" ) lock_teams : Optional [ bool ] = Field ( None , description = \"Whether the player teams are locked\" ) map_size : Optional [ int ] = Field ( None , description = \"The game's map size setting\" ) map_type : Optional [ int ] = Field ( None , description = \"ID of the game's map type\" ) pop : Optional [ int ] = Field ( None , description = \"The max population setting for the game\" ) ranked : Optional [ bool ] = Field ( None , description = \"Whether the lobby is for a ranked game\" ) leaderboard_id : Optional [ int ] = Field ( None , description = \"Leaderboard ID for the game type\" ) rating_type : Optional [ int ] = Field ( None , description = \"The rating ID for the game\" ) resources : Optional [ int ] = Field ( None , description = \"The setting for players' starting resources\" ) rms : Optional [ str ] = Field ( None , description = \"Unclear\" ) scenario : Optional [ str ] = Field ( None , description = \"The activated scenario for the game\" ) server : Optional [ str ] = Field ( None , description = \"The server hosting the game\" ) shared_exploration : Optional [ bool ] = Field ( None , description = \"Whether the map exploration is shared\" ) speed : Optional [ int ] = Field ( None , description = \"The game speed\" ) starting_age : Optional [ int ] = Field ( None , description = \"The starting age for the game\" ) team_together : Optional [ bool ] = Field ( None , description = \"Whether players can team up\" ) team_positions : Optional [ bool ] = Field ( None , description = \"Whether players start with team positions\" ) treaty_length : Optional [ int ] = Field ( None , description = \"Duration of the 'no attack' treaty in minutes\" ) turbo : Optional [ bool ] = Field ( None , description = \"Whether the game will be played in turbo mode\" ) victory : Optional [ int ] = Field ( None , description = \"ID of the game's victory condition\" ) victory_time : Optional [ int ] = Field ( None , description = \"Setting of the victory time limit\" ) visibility : Optional [ int ] = Field ( None , description = \"ID of the visibility setting\" ) opened : Optional [ int ] = Field ( None , description = \"Timestamp of the lobby's creation\" ) started : Optional [ Any ] = Field ( None , description = \"Timestamp of the game's start\" ) finished : Optional [ Any ] = Field ( None , description = \"Timestamp of the game's end\" ) players : Optional [ List [ LobbyMember ]] = Field ( None , description = \"List of members in the lobby\" )","title":"Module aoe2netwrapper.models.lobbies"},{"location":"reference/aoe2netwrapper/models/lobbies/#classes","text":"","title":"Classes"},{"location":"reference/aoe2netwrapper/models/lobbies/#lobbymember","text":"class LobbyMember ( __pydantic_self__ , ** data : Any ) View Source class LobbyMember ( BaseModel ) : \"\"\"An object to encapsulate any entry in the leaderboard ranking.\"\"\" profile_id : Optional [ int ] = Field ( None , description = \"The ID attributed to the member by AoE II\" ) steam_id : Optional [ int ] = Field ( None , description = \"ID of the member on the Steam platform\" ) name : Optional [ str ] = Field ( None , description = \"The member's in-game name\" ) clan : Optional [ str ] = Field ( None , description = \"The member's clan / team\" ) country : Optional [ str ] = Field ( None , description = \"Country the player connected from\" ) slot : Optional [ int ] = Field ( None , description = \"Slot number of the member in the lobby\" ) slot_type : Optional [ int ] = Field ( None , description = \"ID of the role of the member in the lobby\" ) rating : Optional [ int ] = Field ( None , description = \"The member's rating in the ELO system\" ) rating_change : Optional [ Any ] = Field ( None , description = \"The difference to the member's previous rating\" ) games : Optional [ int ] = Field ( None , description = \"The total amount of games played by the member\" ) wins : Optional [ int ] = Field ( None , description = \"Total amount of wins of the member\" ) streak : Optional [ int ] = Field ( None , description = \"Current number of consecutive wins of the member\" ) drops : Optional [ int ] = Field ( None , description = \"Number of games the member dropped out of\" ) color : Optional [ str ] = Field ( None , description = \"The member's in-game color\" ) team : Optional [ str ] = Field ( None , description = \"The member's team number for the game\" ) civ : Optional [ int ] = Field ( None , description = \"The member's civilization pick for the game\" ) won : Optional [ int ] = Field ( None , description = \"Unclear\" )","title":"LobbyMember"},{"location":"reference/aoe2netwrapper/models/lobbies/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/lobbies/#class-variables","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/lobbies/#static-methods","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/lobbies/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/lobbies/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/lobbies/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/lobbies/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/lobbies/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/lobbies/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/lobbies/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/lobbies/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/lobbies/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/lobbies/#instance-variables","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/lobbies/#methods","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/lobbies/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/lobbies/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/lobbies/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/lobbies/#to_string","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/lobbies/#matchlobby","text":"class MatchLobby ( __pydantic_self__ , ** data : Any ) View Source class MatchLobby ( BaseModel ) : \"\"\"An object to encapsulate any entry in the list of returned lobbies.\"\"\" match_id : Optional [ int ] = Field ( None , description = \"ID attributed to the match this lobby is for\" ) lobby_id : Optional [ int ] = Field ( None , description = \"ID attributed to the lobby itself\" ) match_uuid : Optional [ str ] = Field ( None , description = \"UUID attributed to the match this lobby is for\" ) version : Optional [ int ] = Field ( None , description = \"Version number of the game patch\" ) name : Optional [ str ] = Field ( None , description = \"Name given to the lobby\" ) num_players : Optional [ int ] = Field ( None , description = \"Number of players in the lobby\" ) num_slots : Optional [ int ] = Field ( None , description = \"Number of player slots in the lobby\" ) average_rating : Optional [ int ] = Field ( None , description = \"Average rating of the members in the lobby\" ) cheats : Optional [ bool ] = Field ( None , description = \"Whether cheats are enabled\" ) full_tech_tree : Optional [ bool ] = Field ( None , description = \"Whether the full tech tree is set unlocked\" ) ending_age : Optional [ int ] = Field ( None , description = \"The last attainable age for the game\" ) expansion : Optional [ str ] = Field ( None , description = \"The expansion patch enabled\" ) game_type : Optional [ int ] = Field ( None , description = \"ID of the game type, same a leaderboard IDs\" ) has_custom_content : Optional [ bool ] = Field ( None , description = \"Whether the game has custom content\" ) has_password : Optional [ bool ] = Field ( None , description = \"Whether the lobby is password-protected\" ) lock_speed : Optional [ bool ] = Field ( None , description = \"Whether the game speed setting is locked\" ) lock_teams : Optional [ bool ] = Field ( None , description = \"Whether the player teams are locked\" ) map_size : Optional [ int ] = Field ( None , description = \"The game's map size setting\" ) map_type : Optional [ int ] = Field ( None , description = \"ID of the game's map type\" ) pop : Optional [ int ] = Field ( None , description = \"The max population setting for the game\" ) ranked : Optional [ bool ] = Field ( None , description = \"Whether the lobby is for a ranked game\" ) leaderboard_id : Optional [ int ] = Field ( None , description = \"Leaderboard ID for the game type\" ) rating_type : Optional [ int ] = Field ( None , description = \"The rating ID for the game\" ) resources : Optional [ int ] = Field ( None , description = \"The setting for players' starting resources\" ) rms : Optional [ str ] = Field ( None , description = \"Unclear\" ) scenario : Optional [ str ] = Field ( None , description = \"The activated scenario for the game\" ) server : Optional [ str ] = Field ( None , description = \"The server hosting the game\" ) shared_exploration : Optional [ bool ] = Field ( None , description = \"Whether the map exploration is shared\" ) speed : Optional [ int ] = Field ( None , description = \"The game speed\" ) starting_age : Optional [ int ] = Field ( None , description = \"The starting age for the game\" ) team_together : Optional [ bool ] = Field ( None , description = \"Whether players can team up\" ) team_positions : Optional [ bool ] = Field ( None , description = \"Whether players start with team positions\" ) treaty_length : Optional [ int ] = Field ( None , description = \"Duration of the 'no attack' treaty in minutes\" ) turbo : Optional [ bool ] = Field ( None , description = \"Whether the game will be played in turbo mode\" ) victory : Optional [ int ] = Field ( None , description = \"ID of the game's victory condition\" ) victory_time : Optional [ int ] = Field ( None , description = \"Setting of the victory time limit\" ) visibility : Optional [ int ] = Field ( None , description = \"ID of the visibility setting\" ) opened : Optional [ int ] = Field ( None , description = \"Timestamp of the lobby's creation\" ) started : Optional [ Any ] = Field ( None , description = \"Timestamp of the game's start\" ) finished : Optional [ Any ] = Field ( None , description = \"Timestamp of the game's end\" ) players : Optional [ List[LobbyMember ] ] = Field ( None , description = \"List of members in the lobby\" )","title":"MatchLobby"},{"location":"reference/aoe2netwrapper/models/lobbies/#ancestors-in-mro_1","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/lobbies/#class-variables_1","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/lobbies/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/lobbies/#construct_1","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/lobbies/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/lobbies/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/lobbies/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/lobbies/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/lobbies/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/lobbies/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/lobbies/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/lobbies/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/lobbies/#instance-variables_1","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/lobbies/#methods_1","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/lobbies/#copy_1","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/lobbies/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/lobbies/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/lobbies/#to_string_1","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/match/","text":"Module aoe2netwrapper.models.match aoe2netwrapper.models.match This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/match View Source \"\"\" aoe2netwrapper.models.match --------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/match \"\"\" # pylint: disable=unused-import from aoe2netwrapper.models.lobbies import MatchLobby as MatchLobby # noqa","title":"Match"},{"location":"reference/aoe2netwrapper/models/match/#module-aoe2netwrappermodelsmatch","text":"aoe2netwrapper.models.match This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/match View Source \"\"\" aoe2netwrapper.models.match --------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/match \"\"\" # pylint: disable=unused-import from aoe2netwrapper.models.lobbies import MatchLobby as MatchLobby # noqa","title":"Module aoe2netwrapper.models.match"},{"location":"reference/aoe2netwrapper/models/match_history/","text":"Module aoe2netwrapper.models.match_history aoe2netwrapper.models.match_history This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/player/matches View Source \"\"\" aoe2netwrapper.models.match_history ----------------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/player/matches \"\"\" # pylint: disable=unused-import from aoe2netwrapper.models.lobbies import MatchLobby as MatchLobby # noqa","title":"Match History"},{"location":"reference/aoe2netwrapper/models/match_history/#module-aoe2netwrappermodelsmatch_history","text":"aoe2netwrapper.models.match_history This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/player/matches View Source \"\"\" aoe2netwrapper.models.match_history ----------------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/player/matches \"\"\" # pylint: disable=unused-import from aoe2netwrapper.models.lobbies import MatchLobby as MatchLobby # noqa","title":"Module aoe2netwrapper.models.match_history"},{"location":"reference/aoe2netwrapper/models/matches/","text":"Module aoe2netwrapper.models.matches aoe2netwrapper.models.matches This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/matches View Source \"\"\" aoe2netwrapper.models.matches ----------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/matches \"\"\" # pylint: disable=unused-import from aoe2netwrapper.models.lobbies import MatchLobby as MatchLobby # noqa","title":"Matches"},{"location":"reference/aoe2netwrapper/models/matches/#module-aoe2netwrappermodelsmatches","text":"aoe2netwrapper.models.matches This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/matches View Source \"\"\" aoe2netwrapper.models.matches ----------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/matches \"\"\" # pylint: disable=unused-import from aoe2netwrapper.models.lobbies import MatchLobby as MatchLobby # noqa","title":"Module aoe2netwrapper.models.matches"},{"location":"reference/aoe2netwrapper/models/num_online/","text":"Module aoe2netwrapper.models.num_online aoe2netwrapper.models.num_online This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/stats/players View Source \"\"\" aoe2netwrapper.models.num_online -------------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/stats/players \"\"\" from typing import List , Optional from pydantic import BaseModel , Field class NumPlayers ( BaseModel ): \"\"\"A model to encapsulate the metrics from the num_online API.\"\"\" steam : Optional [ int ] = Field ( None , description = \"Number of players from Steam\" ) multiplayer : Optional [ int ] = Field ( None , description = \"Number of people playing multiplayer\" ) looking : Optional [ int ] = Field ( None , description = \"Number of players currently looking for a game\" ) in_game : Optional [ int ] = Field ( None , description = \"Number of players currently playing\" ) multiplayer_1h : Optional [ int ] = Field ( None , description = \"Number of multiplayer players the past hour\" ) multiplayer_24h : Optional [ int ] = Field ( None , description = \"Number of multiplayer players the past 24 hour\" ) class PlayerCountTimePoint ( BaseModel ): \"\"\"A model to encapsulate a timestamp datapoint of the num_online API metrics.\"\"\" time : Optional [ int ] = Field ( None , description = \"Timestamp of the metrics data point\" ) num_players : Optional [ NumPlayers ] = Field ( None , description = \"A NumPlayer object with the metrics\" ) class NumOnlineResponse ( BaseModel ): \"\"\"A model to encapsulate the response from the num_online API.\"\"\" app_id : Optional [ int ] = Field ( None , description = \"Unclear\" ) player_stats : Optional [ List [ PlayerCountTimePoint ]] = Field ( None , description = \"List of metrics at different points in time\" ) Classes NumOnlineResponse class NumOnlineResponse ( __pydantic_self__ , ** data : Any ) View Source class NumOnlineResponse ( BaseModel ) : \"\"\"A model to encapsulate the response from the num_online API.\"\"\" app_id : Optional [ int ] = Field ( None , description = \"Unclear\" ) player_stats : Optional [ List[PlayerCountTimePoint ] ] = Field ( None , description = \"List of metrics at different points in time\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' NumPlayers class NumPlayers ( __pydantic_self__ , ** data : Any ) View Source class NumPlayers ( BaseModel ) : \"\"\"A model to encapsulate the metrics from the num_online API.\"\"\" steam : Optional [ int ] = Field ( None , description = \"Number of players from Steam\" ) multiplayer : Optional [ int ] = Field ( None , description = \"Number of people playing multiplayer\" ) looking : Optional [ int ] = Field ( None , description = \"Number of players currently looking for a game\" ) in_game : Optional [ int ] = Field ( None , description = \"Number of players currently playing\" ) multiplayer_1h : Optional [ int ] = Field ( None , description = \"Number of multiplayer players the past hour\" ) multiplayer_24h : Optional [ int ] = Field ( None , description = \"Number of multiplayer players the past 24 hour\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' PlayerCountTimePoint class PlayerCountTimePoint ( __pydantic_self__ , ** data : Any ) View Source class PlayerCountTimePoint ( BaseModel ) : \"\"\"A model to encapsulate a timestamp datapoint of the num_online API metrics.\"\"\" time : Optional [ int ] = Field ( None , description = \"Timestamp of the metrics data point\" ) num_players : Optional [ NumPlayers ] = Field ( None , description = \"A NumPlayer object with the metrics\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"Num Online"},{"location":"reference/aoe2netwrapper/models/num_online/#module-aoe2netwrappermodelsnum_online","text":"aoe2netwrapper.models.num_online This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/stats/players View Source \"\"\" aoe2netwrapper.models.num_online -------------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/stats/players \"\"\" from typing import List , Optional from pydantic import BaseModel , Field class NumPlayers ( BaseModel ): \"\"\"A model to encapsulate the metrics from the num_online API.\"\"\" steam : Optional [ int ] = Field ( None , description = \"Number of players from Steam\" ) multiplayer : Optional [ int ] = Field ( None , description = \"Number of people playing multiplayer\" ) looking : Optional [ int ] = Field ( None , description = \"Number of players currently looking for a game\" ) in_game : Optional [ int ] = Field ( None , description = \"Number of players currently playing\" ) multiplayer_1h : Optional [ int ] = Field ( None , description = \"Number of multiplayer players the past hour\" ) multiplayer_24h : Optional [ int ] = Field ( None , description = \"Number of multiplayer players the past 24 hour\" ) class PlayerCountTimePoint ( BaseModel ): \"\"\"A model to encapsulate a timestamp datapoint of the num_online API metrics.\"\"\" time : Optional [ int ] = Field ( None , description = \"Timestamp of the metrics data point\" ) num_players : Optional [ NumPlayers ] = Field ( None , description = \"A NumPlayer object with the metrics\" ) class NumOnlineResponse ( BaseModel ): \"\"\"A model to encapsulate the response from the num_online API.\"\"\" app_id : Optional [ int ] = Field ( None , description = \"Unclear\" ) player_stats : Optional [ List [ PlayerCountTimePoint ]] = Field ( None , description = \"List of metrics at different points in time\" )","title":"Module aoe2netwrapper.models.num_online"},{"location":"reference/aoe2netwrapper/models/num_online/#classes","text":"","title":"Classes"},{"location":"reference/aoe2netwrapper/models/num_online/#numonlineresponse","text":"class NumOnlineResponse ( __pydantic_self__ , ** data : Any ) View Source class NumOnlineResponse ( BaseModel ) : \"\"\"A model to encapsulate the response from the num_online API.\"\"\" app_id : Optional [ int ] = Field ( None , description = \"Unclear\" ) player_stats : Optional [ List[PlayerCountTimePoint ] ] = Field ( None , description = \"List of metrics at different points in time\" )","title":"NumOnlineResponse"},{"location":"reference/aoe2netwrapper/models/num_online/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/num_online/#class-variables","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/num_online/#static-methods","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/num_online/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/num_online/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/num_online/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/num_online/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/num_online/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/num_online/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/num_online/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/num_online/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/num_online/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/num_online/#instance-variables","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/num_online/#methods","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/num_online/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/num_online/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/num_online/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/num_online/#to_string","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/num_online/#numplayers","text":"class NumPlayers ( __pydantic_self__ , ** data : Any ) View Source class NumPlayers ( BaseModel ) : \"\"\"A model to encapsulate the metrics from the num_online API.\"\"\" steam : Optional [ int ] = Field ( None , description = \"Number of players from Steam\" ) multiplayer : Optional [ int ] = Field ( None , description = \"Number of people playing multiplayer\" ) looking : Optional [ int ] = Field ( None , description = \"Number of players currently looking for a game\" ) in_game : Optional [ int ] = Field ( None , description = \"Number of players currently playing\" ) multiplayer_1h : Optional [ int ] = Field ( None , description = \"Number of multiplayer players the past hour\" ) multiplayer_24h : Optional [ int ] = Field ( None , description = \"Number of multiplayer players the past 24 hour\" )","title":"NumPlayers"},{"location":"reference/aoe2netwrapper/models/num_online/#ancestors-in-mro_1","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/num_online/#class-variables_1","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/num_online/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/num_online/#construct_1","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/num_online/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/num_online/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/num_online/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/num_online/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/num_online/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/num_online/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/num_online/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/num_online/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/num_online/#instance-variables_1","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/num_online/#methods_1","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/num_online/#copy_1","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/num_online/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/num_online/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/num_online/#to_string_1","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/num_online/#playercounttimepoint","text":"class PlayerCountTimePoint ( __pydantic_self__ , ** data : Any ) View Source class PlayerCountTimePoint ( BaseModel ) : \"\"\"A model to encapsulate a timestamp datapoint of the num_online API metrics.\"\"\" time : Optional [ int ] = Field ( None , description = \"Timestamp of the metrics data point\" ) num_players : Optional [ NumPlayers ] = Field ( None , description = \"A NumPlayer object with the metrics\" )","title":"PlayerCountTimePoint"},{"location":"reference/aoe2netwrapper/models/num_online/#ancestors-in-mro_2","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/num_online/#class-variables_2","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/num_online/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/num_online/#construct_2","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/num_online/#from_orm_2","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/num_online/#parse_file_2","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/num_online/#parse_obj_2","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/num_online/#parse_raw_2","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/num_online/#schema_2","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/num_online/#schema_json_2","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/num_online/#update_forward_refs_2","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/num_online/#validate_2","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/num_online/#instance-variables_2","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/num_online/#methods_2","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/num_online/#copy_2","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/num_online/#dict_2","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/num_online/#json_2","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/num_online/#to_string_2","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/rating_history/","text":"Module aoe2netwrapper.models.rating_history aoe2netwrapper.models.rating_history This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/player/ratinghistory View Source \"\"\" aoe2netwrapper.models.rating_history ------------------------------------ This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/player/ratinghistory \"\"\" from typing import Optional from pydantic import BaseModel , Field class RatingTimePoint ( BaseModel ): \"\"\"An object to encapsulate any entry in the list of returned ranking timestamped data points.\"\"\" rating : Optional [ int ] = Field ( None , description = \"The player's rating in the ELO system\" ) num_wins : Optional [ int ] = Field ( None , description = \"Total amount of wins\" ) num_losses : Optional [ int ] = Field ( None , description = \"Total amount of losses\" ) streak : Optional [ int ] = Field ( None , description = \"Current number of consecutive wins\" ) drops : Optional [ int ] = Field ( None , description = \"Number of games dropped out of\" ) timestamp : Optional [ int ] = Field ( None , description = \"Timestamp of the metrics\" ) Classes RatingTimePoint class RatingTimePoint ( __pydantic_self__ , ** data : Any ) View Source class RatingTimePoint ( BaseModel ) : \"\"\"An object to encapsulate any entry in the list of returned ranking timestamped data points.\"\"\" rating : Optional [ int ] = Field ( None , description = \"The player's rating in the ELO system\" ) num_wins : Optional [ int ] = Field ( None , description = \"Total amount of wins\" ) num_losses : Optional [ int ] = Field ( None , description = \"Total amount of losses\" ) streak : Optional [ int ] = Field ( None , description = \"Current number of consecutive wins\" ) drops : Optional [ int ] = Field ( None , description = \"Number of games dropped out of\" ) timestamp : Optional [ int ] = Field ( None , description = \"Timestamp of the metrics\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"Rating History"},{"location":"reference/aoe2netwrapper/models/rating_history/#module-aoe2netwrappermodelsrating_history","text":"aoe2netwrapper.models.rating_history This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/player/ratinghistory View Source \"\"\" aoe2netwrapper.models.rating_history ------------------------------------ This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/player/ratinghistory \"\"\" from typing import Optional from pydantic import BaseModel , Field class RatingTimePoint ( BaseModel ): \"\"\"An object to encapsulate any entry in the list of returned ranking timestamped data points.\"\"\" rating : Optional [ int ] = Field ( None , description = \"The player's rating in the ELO system\" ) num_wins : Optional [ int ] = Field ( None , description = \"Total amount of wins\" ) num_losses : Optional [ int ] = Field ( None , description = \"Total amount of losses\" ) streak : Optional [ int ] = Field ( None , description = \"Current number of consecutive wins\" ) drops : Optional [ int ] = Field ( None , description = \"Number of games dropped out of\" ) timestamp : Optional [ int ] = Field ( None , description = \"Timestamp of the metrics\" )","title":"Module aoe2netwrapper.models.rating_history"},{"location":"reference/aoe2netwrapper/models/rating_history/#classes","text":"","title":"Classes"},{"location":"reference/aoe2netwrapper/models/rating_history/#ratingtimepoint","text":"class RatingTimePoint ( __pydantic_self__ , ** data : Any ) View Source class RatingTimePoint ( BaseModel ) : \"\"\"An object to encapsulate any entry in the list of returned ranking timestamped data points.\"\"\" rating : Optional [ int ] = Field ( None , description = \"The player's rating in the ELO system\" ) num_wins : Optional [ int ] = Field ( None , description = \"Total amount of wins\" ) num_losses : Optional [ int ] = Field ( None , description = \"Total amount of losses\" ) streak : Optional [ int ] = Field ( None , description = \"Current number of consecutive wins\" ) drops : Optional [ int ] = Field ( None , description = \"Number of games dropped out of\" ) timestamp : Optional [ int ] = Field ( None , description = \"Timestamp of the metrics\" )","title":"RatingTimePoint"},{"location":"reference/aoe2netwrapper/models/rating_history/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/rating_history/#class-variables","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/rating_history/#static-methods","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/rating_history/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/rating_history/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/rating_history/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/rating_history/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/rating_history/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/rating_history/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/rating_history/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/rating_history/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/rating_history/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/rating_history/#instance-variables","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/rating_history/#methods","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/rating_history/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/rating_history/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/rating_history/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/rating_history/#to_string","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/strings/","text":"Module aoe2netwrapper.models.strings aoe2netwrapper.models.strings This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/strings Any confusing with a specific attribute being an INTEGER in the models can be cleared by checking the corresponding string the API / system attributes to this ID. View Source \"\"\" aoe2netwrapper.models.strings ----------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/strings Any confusing with a specific attribute being an INTEGER in the models can be cleared by checking the corresponding string the API / system attributes to this ID. \"\"\" from typing import List , Optional from pydantic import BaseModel , Field class AgeString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available age strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'age' ID\" ) class CivilizationString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available civilization strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'civ' ID\" ) class GameTypeString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available game type strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'game_type' ID\" ) class LeaderBoardString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available leaderboard strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'leaderboard' ID\" ) class MapSizeString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available map size strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'map_size' ID\" ) class MapTypeString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available map type strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'map_type' ID\" ) class RatingTypeString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available rating type strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'rating_type' ID\" ) class ResourcesString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available resources strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'resources' ID\" ) class SpeedString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available speed strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'speed' ID\" ) class VictoryString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available victory strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'victory' ID\" ) class VisibilityString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available visibiliity strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'visibility' ID\" ) class StringsResponse ( BaseModel ): \"\"\"An object to encapsulate the response from the strings API endpoint.\"\"\" language : Optional [ str ] = Field ( None , description = \"Language of the returned strings\" ) age : Optional [ List [ AgeString ]] = Field ( None , description = \"List of all strings and their IDs for ages\" ) civ : Optional [ List [ CivilizationString ]] = Field ( None , description = \"List of all strings and their IDs for civilizations\" ) game_type : Optional [ List [ GameTypeString ]] = Field ( None , description = \"List of all strings and their IDs for game types\" ) leaderboard : Optional [ List [ LeaderBoardString ]] = Field ( None , description = \"List of all strings and their IDs for leaderboards\" ) map_size : Optional [ List [ MapSizeString ]] = Field ( None , description = \"List of all strings and their IDs for map sizes\" ) map_type : Optional [ List [ MapTypeString ]] = Field ( None , description = \"List of all strings and their IDs for map types\" ) rating_type : Optional [ List [ RatingTypeString ]] = Field ( None , description = \"List of all strings and their IDs for rating types\" ) resources : Optional [ List [ ResourcesString ]] = Field ( None , description = \"List of all strings and their IDs for resources\" ) speed : Optional [ List [ SpeedString ]] = Field ( None , description = \"List of all strings and their IDs for game speeds\" ) victory : Optional [ List [ VictoryString ]] = Field ( None , description = \"List of all strings and their IDs for victory types\" ) visibility : Optional [ List [ VisibilityString ]] = Field ( None , description = \"List of all strings and their IDs for visibility\" ) Classes AgeString class AgeString ( __pydantic_self__ , ** data : Any ) View Source class AgeString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available age strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'age' ID\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' CivilizationString class CivilizationString ( __pydantic_self__ , ** data : Any ) View Source class CivilizationString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available civilization strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'civ' ID\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' GameTypeString class GameTypeString ( __pydantic_self__ , ** data : Any ) View Source class GameTypeString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available game type strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'game_type' ID\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' LeaderBoardString class LeaderBoardString ( __pydantic_self__ , ** data : Any ) View Source class LeaderBoardString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available leaderboard strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'leaderboard' ID\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' MapSizeString class MapSizeString ( __pydantic_self__ , ** data : Any ) View Source class MapSizeString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available map size strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'map_size' ID\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' MapTypeString class MapTypeString ( __pydantic_self__ , ** data : Any ) View Source class MapTypeString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available map type strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'map_type' ID\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' RatingTypeString class RatingTypeString ( __pydantic_self__ , ** data : Any ) View Source class RatingTypeString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available rating type strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'rating_type' ID\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' ResourcesString class ResourcesString ( __pydantic_self__ , ** data : Any ) View Source class ResourcesString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available resources strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'resources' ID\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' SpeedString class SpeedString ( __pydantic_self__ , ** data : Any ) View Source class SpeedString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available speed strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'speed' ID\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' StringsResponse class StringsResponse ( __pydantic_self__ , ** data : Any ) View Source class StringsResponse ( BaseModel ) : \"\"\"An object to encapsulate the response from the strings API endpoint.\"\"\" language : Optional [ str ] = Field ( None , description = \"Language of the returned strings\" ) age : Optional [ List[AgeString ] ] = Field ( None , description = \"List of all strings and their IDs for ages\" ) civ : Optional [ List[CivilizationString ] ] = Field ( None , description = \"List of all strings and their IDs for civilizations\" ) game_type : Optional [ List[GameTypeString ] ] = Field ( None , description = \"List of all strings and their IDs for game types\" ) leaderboard : Optional [ List[LeaderBoardString ] ] = Field ( None , description = \"List of all strings and their IDs for leaderboards\" ) map_size : Optional [ List[MapSizeString ] ] = Field ( None , description = \"List of all strings and their IDs for map sizes\" ) map_type : Optional [ List[MapTypeString ] ] = Field ( None , description = \"List of all strings and their IDs for map types\" ) rating_type : Optional [ List[RatingTypeString ] ] = Field ( None , description = \"List of all strings and their IDs for rating types\" ) resources : Optional [ List[ResourcesString ] ] = Field ( None , description = \"List of all strings and their IDs for resources\" ) speed : Optional [ List[SpeedString ] ] = Field ( None , description = \"List of all strings and their IDs for game speeds\" ) victory : Optional [ List[VictoryString ] ] = Field ( None , description = \"List of all strings and their IDs for victory types\" ) visibility : Optional [ List[VisibilityString ] ] = Field ( None , description = \"List of all strings and their IDs for visibility\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' VictoryString class VictoryString ( __pydantic_self__ , ** data : Any ) View Source class VictoryString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available victory strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'victory' ID\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' VisibilityString class VisibilityString ( __pydantic_self__ , ** data : Any ) View Source class VisibilityString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available visibiliity strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'visibility' ID\" ) Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"Strings"},{"location":"reference/aoe2netwrapper/models/strings/#module-aoe2netwrappermodelsstrings","text":"aoe2netwrapper.models.strings This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/strings Any confusing with a specific attribute being an INTEGER in the models can be cleared by checking the corresponding string the API / system attributes to this ID. View Source \"\"\" aoe2netwrapper.models.strings ----------------------------- This module contains the model objects to encapsulate the responses from the endpoint at https://aoe2.net/api/strings Any confusing with a specific attribute being an INTEGER in the models can be cleared by checking the corresponding string the API / system attributes to this ID. \"\"\" from typing import List , Optional from pydantic import BaseModel , Field class AgeString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available age strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'age' ID\" ) class CivilizationString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available civilization strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'civ' ID\" ) class GameTypeString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available game type strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'game_type' ID\" ) class LeaderBoardString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available leaderboard strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'leaderboard' ID\" ) class MapSizeString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available map size strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'map_size' ID\" ) class MapTypeString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available map type strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'map_type' ID\" ) class RatingTypeString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available rating type strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'rating_type' ID\" ) class ResourcesString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available resources strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'resources' ID\" ) class SpeedString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available speed strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'speed' ID\" ) class VictoryString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available victory strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'victory' ID\" ) class VisibilityString ( BaseModel ): \"\"\"An object to encapsulate any entry for the available visibiliity strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'visibility' ID\" ) class StringsResponse ( BaseModel ): \"\"\"An object to encapsulate the response from the strings API endpoint.\"\"\" language : Optional [ str ] = Field ( None , description = \"Language of the returned strings\" ) age : Optional [ List [ AgeString ]] = Field ( None , description = \"List of all strings and their IDs for ages\" ) civ : Optional [ List [ CivilizationString ]] = Field ( None , description = \"List of all strings and their IDs for civilizations\" ) game_type : Optional [ List [ GameTypeString ]] = Field ( None , description = \"List of all strings and their IDs for game types\" ) leaderboard : Optional [ List [ LeaderBoardString ]] = Field ( None , description = \"List of all strings and their IDs for leaderboards\" ) map_size : Optional [ List [ MapSizeString ]] = Field ( None , description = \"List of all strings and their IDs for map sizes\" ) map_type : Optional [ List [ MapTypeString ]] = Field ( None , description = \"List of all strings and their IDs for map types\" ) rating_type : Optional [ List [ RatingTypeString ]] = Field ( None , description = \"List of all strings and their IDs for rating types\" ) resources : Optional [ List [ ResourcesString ]] = Field ( None , description = \"List of all strings and their IDs for resources\" ) speed : Optional [ List [ SpeedString ]] = Field ( None , description = \"List of all strings and their IDs for game speeds\" ) victory : Optional [ List [ VictoryString ]] = Field ( None , description = \"List of all strings and their IDs for victory types\" ) visibility : Optional [ List [ VisibilityString ]] = Field ( None , description = \"List of all strings and their IDs for visibility\" )","title":"Module aoe2netwrapper.models.strings"},{"location":"reference/aoe2netwrapper/models/strings/#classes","text":"","title":"Classes"},{"location":"reference/aoe2netwrapper/models/strings/#agestring","text":"class AgeString ( __pydantic_self__ , ** data : Any ) View Source class AgeString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available age strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'age' ID\" )","title":"AgeString"},{"location":"reference/aoe2netwrapper/models/strings/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/strings/#class-variables","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/strings/#static-methods","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/strings/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/strings/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/strings/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/strings/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/strings/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/strings/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/strings/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/strings/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/strings/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/strings/#instance-variables","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/strings/#methods","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/strings/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/strings/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/strings/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/strings/#to_string","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/strings/#civilizationstring","text":"class CivilizationString ( __pydantic_self__ , ** data : Any ) View Source class CivilizationString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available civilization strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'civ' ID\" )","title":"CivilizationString"},{"location":"reference/aoe2netwrapper/models/strings/#ancestors-in-mro_1","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/strings/#class-variables_1","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/strings/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/strings/#construct_1","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/strings/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/strings/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/strings/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/strings/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/strings/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/strings/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/strings/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/strings/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/strings/#instance-variables_1","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/strings/#methods_1","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/strings/#copy_1","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/strings/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/strings/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/strings/#to_string_1","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/strings/#gametypestring","text":"class GameTypeString ( __pydantic_self__ , ** data : Any ) View Source class GameTypeString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available game type strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'game_type' ID\" )","title":"GameTypeString"},{"location":"reference/aoe2netwrapper/models/strings/#ancestors-in-mro_2","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/strings/#class-variables_2","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/strings/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/strings/#construct_2","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/strings/#from_orm_2","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/strings/#parse_file_2","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/strings/#parse_obj_2","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/strings/#parse_raw_2","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/strings/#schema_2","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/strings/#schema_json_2","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/strings/#update_forward_refs_2","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/strings/#validate_2","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/strings/#instance-variables_2","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/strings/#methods_2","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/strings/#copy_2","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/strings/#dict_2","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/strings/#json_2","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/strings/#to_string_2","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/strings/#leaderboardstring","text":"class LeaderBoardString ( __pydantic_self__ , ** data : Any ) View Source class LeaderBoardString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available leaderboard strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'leaderboard' ID\" )","title":"LeaderBoardString"},{"location":"reference/aoe2netwrapper/models/strings/#ancestors-in-mro_3","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/strings/#class-variables_3","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/strings/#static-methods_3","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/strings/#construct_3","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/strings/#from_orm_3","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/strings/#parse_file_3","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/strings/#parse_obj_3","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/strings/#parse_raw_3","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/strings/#schema_3","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/strings/#schema_json_3","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/strings/#update_forward_refs_3","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/strings/#validate_3","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/strings/#instance-variables_3","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/strings/#methods_3","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/strings/#copy_3","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/strings/#dict_3","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/strings/#json_3","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/strings/#to_string_3","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/strings/#mapsizestring","text":"class MapSizeString ( __pydantic_self__ , ** data : Any ) View Source class MapSizeString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available map size strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'map_size' ID\" )","title":"MapSizeString"},{"location":"reference/aoe2netwrapper/models/strings/#ancestors-in-mro_4","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/strings/#class-variables_4","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/strings/#static-methods_4","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/strings/#construct_4","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/strings/#from_orm_4","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/strings/#parse_file_4","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/strings/#parse_obj_4","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/strings/#parse_raw_4","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/strings/#schema_4","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/strings/#schema_json_4","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/strings/#update_forward_refs_4","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/strings/#validate_4","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/strings/#instance-variables_4","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/strings/#methods_4","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/strings/#copy_4","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/strings/#dict_4","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/strings/#json_4","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/strings/#to_string_4","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/strings/#maptypestring","text":"class MapTypeString ( __pydantic_self__ , ** data : Any ) View Source class MapTypeString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available map type strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'map_type' ID\" )","title":"MapTypeString"},{"location":"reference/aoe2netwrapper/models/strings/#ancestors-in-mro_5","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/strings/#class-variables_5","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/strings/#static-methods_5","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/strings/#construct_5","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/strings/#from_orm_5","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/strings/#parse_file_5","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/strings/#parse_obj_5","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/strings/#parse_raw_5","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/strings/#schema_5","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/strings/#schema_json_5","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/strings/#update_forward_refs_5","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/strings/#validate_5","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/strings/#instance-variables_5","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/strings/#methods_5","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/strings/#copy_5","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/strings/#dict_5","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/strings/#json_5","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/strings/#to_string_5","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/strings/#ratingtypestring","text":"class RatingTypeString ( __pydantic_self__ , ** data : Any ) View Source class RatingTypeString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available rating type strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'rating_type' ID\" )","title":"RatingTypeString"},{"location":"reference/aoe2netwrapper/models/strings/#ancestors-in-mro_6","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/strings/#class-variables_6","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/strings/#static-methods_6","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/strings/#construct_6","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/strings/#from_orm_6","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/strings/#parse_file_6","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/strings/#parse_obj_6","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/strings/#parse_raw_6","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/strings/#schema_6","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/strings/#schema_json_6","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/strings/#update_forward_refs_6","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/strings/#validate_6","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/strings/#instance-variables_6","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/strings/#methods_6","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/strings/#copy_6","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/strings/#dict_6","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/strings/#json_6","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/strings/#to_string_6","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/strings/#resourcesstring","text":"class ResourcesString ( __pydantic_self__ , ** data : Any ) View Source class ResourcesString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available resources strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'resources' ID\" )","title":"ResourcesString"},{"location":"reference/aoe2netwrapper/models/strings/#ancestors-in-mro_7","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/strings/#class-variables_7","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/strings/#static-methods_7","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/strings/#construct_7","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/strings/#from_orm_7","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/strings/#parse_file_7","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/strings/#parse_obj_7","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/strings/#parse_raw_7","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/strings/#schema_7","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/strings/#schema_json_7","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/strings/#update_forward_refs_7","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/strings/#validate_7","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/strings/#instance-variables_7","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/strings/#methods_7","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/strings/#copy_7","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/strings/#dict_7","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/strings/#json_7","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/strings/#to_string_7","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/strings/#speedstring","text":"class SpeedString ( __pydantic_self__ , ** data : Any ) View Source class SpeedString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available speed strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'speed' ID\" )","title":"SpeedString"},{"location":"reference/aoe2netwrapper/models/strings/#ancestors-in-mro_8","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/strings/#class-variables_8","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/strings/#static-methods_8","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/strings/#construct_8","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/strings/#from_orm_8","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/strings/#parse_file_8","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/strings/#parse_obj_8","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/strings/#parse_raw_8","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/strings/#schema_8","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/strings/#schema_json_8","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/strings/#update_forward_refs_8","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/strings/#validate_8","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/strings/#instance-variables_8","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/strings/#methods_8","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/strings/#copy_8","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/strings/#dict_8","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/strings/#json_8","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/strings/#to_string_8","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/strings/#stringsresponse","text":"class StringsResponse ( __pydantic_self__ , ** data : Any ) View Source class StringsResponse ( BaseModel ) : \"\"\"An object to encapsulate the response from the strings API endpoint.\"\"\" language : Optional [ str ] = Field ( None , description = \"Language of the returned strings\" ) age : Optional [ List[AgeString ] ] = Field ( None , description = \"List of all strings and their IDs for ages\" ) civ : Optional [ List[CivilizationString ] ] = Field ( None , description = \"List of all strings and their IDs for civilizations\" ) game_type : Optional [ List[GameTypeString ] ] = Field ( None , description = \"List of all strings and their IDs for game types\" ) leaderboard : Optional [ List[LeaderBoardString ] ] = Field ( None , description = \"List of all strings and their IDs for leaderboards\" ) map_size : Optional [ List[MapSizeString ] ] = Field ( None , description = \"List of all strings and their IDs for map sizes\" ) map_type : Optional [ List[MapTypeString ] ] = Field ( None , description = \"List of all strings and their IDs for map types\" ) rating_type : Optional [ List[RatingTypeString ] ] = Field ( None , description = \"List of all strings and their IDs for rating types\" ) resources : Optional [ List[ResourcesString ] ] = Field ( None , description = \"List of all strings and their IDs for resources\" ) speed : Optional [ List[SpeedString ] ] = Field ( None , description = \"List of all strings and their IDs for game speeds\" ) victory : Optional [ List[VictoryString ] ] = Field ( None , description = \"List of all strings and their IDs for victory types\" ) visibility : Optional [ List[VisibilityString ] ] = Field ( None , description = \"List of all strings and their IDs for visibility\" )","title":"StringsResponse"},{"location":"reference/aoe2netwrapper/models/strings/#ancestors-in-mro_9","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/strings/#class-variables_9","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/strings/#static-methods_9","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/strings/#construct_9","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/strings/#from_orm_9","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/strings/#parse_file_9","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/strings/#parse_obj_9","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/strings/#parse_raw_9","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/strings/#schema_9","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/strings/#schema_json_9","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/strings/#update_forward_refs_9","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/strings/#validate_9","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/strings/#instance-variables_9","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/strings/#methods_9","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/strings/#copy_9","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/strings/#dict_9","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/strings/#json_9","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/strings/#to_string_9","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/strings/#victorystring","text":"class VictoryString ( __pydantic_self__ , ** data : Any ) View Source class VictoryString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available victory strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'victory' ID\" )","title":"VictoryString"},{"location":"reference/aoe2netwrapper/models/strings/#ancestors-in-mro_10","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/strings/#class-variables_10","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/strings/#static-methods_10","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/strings/#construct_10","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/strings/#from_orm_10","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/strings/#parse_file_10","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/strings/#parse_obj_10","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/strings/#parse_raw_10","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/strings/#schema_10","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/strings/#schema_json_10","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/strings/#update_forward_refs_10","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/strings/#validate_10","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/strings/#instance-variables_10","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/strings/#methods_10","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/strings/#copy_10","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/strings/#dict_10","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/strings/#json_10","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/strings/#to_string_10","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/aoe2netwrapper/models/strings/#visibilitystring","text":"class VisibilityString ( __pydantic_self__ , ** data : Any ) View Source class VisibilityString ( BaseModel ) : \"\"\"An object to encapsulate any entry for the available visibiliity strings and their respective IDs.\"\"\" id : Optional [ int ] = Field ( None , description = \"ID for this specific string value\" ) string : Optional [ str ] = Field ( None , description = \"String value for this specific 'visibility' ID\" )","title":"VisibilityString"},{"location":"reference/aoe2netwrapper/models/strings/#ancestors-in-mro_11","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/aoe2netwrapper/models/strings/#class-variables_11","text":"Config","title":"Class variables"},{"location":"reference/aoe2netwrapper/models/strings/#static-methods_11","text":"","title":"Static methods"},{"location":"reference/aoe2netwrapper/models/strings/#construct_11","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/aoe2netwrapper/models/strings/#from_orm_11","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/aoe2netwrapper/models/strings/#parse_file_11","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/aoe2netwrapper/models/strings/#parse_obj_11","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/aoe2netwrapper/models/strings/#parse_raw_11","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/aoe2netwrapper/models/strings/#schema_11","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/aoe2netwrapper/models/strings/#schema_json_11","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/aoe2netwrapper/models/strings/#update_forward_refs_11","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/aoe2netwrapper/models/strings/#validate_11","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/aoe2netwrapper/models/strings/#instance-variables_11","text":"fields","title":"Instance variables"},{"location":"reference/aoe2netwrapper/models/strings/#methods_11","text":"","title":"Methods"},{"location":"reference/aoe2netwrapper/models/strings/#copy_11","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/aoe2netwrapper/models/strings/#dict_11","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/aoe2netwrapper/models/strings/#json_11","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/aoe2netwrapper/models/strings/#to_string_11","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"}]}